[{"categories":null,"content":"测试页面，添加新功能的时候测试用","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"添加音乐 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:0","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"美国Billboard榜 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:1","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"周杰伦快歌 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:2","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"周杰伦 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:3","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"陶喆 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:4","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"南拳妈妈 ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:1:5","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":null,"content":"添加bilibili视频 {{\u003c bilibili xxx \u003e}} ","date":"2021-08-12","objectID":"/posts/aaaa_ceshi/:2:0","tags":null,"title":"测试内容-置顶第一篇","uri":"/posts/aaaa_ceshi/"},{"categories":["unity"],"content":"VSCode编辑Lua与调试Lua的初始化安装","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"下载安装 下载vscode并安装，安装位置随意。 ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:1:0","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"插件安装 Tip : 插件可以先全部安装好，再对各个插件进行相应设置 ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:2:0","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"Chinese(Simplified)(简体中文) 默认VSCode是英文版，先安装中文插件。在左侧导航栏的四个方格的按钮或者快捷键(ctrl+shift+x)，在搜索栏中输入chinese,点击中文简体进行安装，看到卸载按钮为安装好了，安装完重启软件。 ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:2:1","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"lua(作者:sumneko) 安装方式同上 ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:2:2","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"LuaPanda(调试工具) 安装方式同上 下载github内luapanda_matser整个工程调式器快速试用页面(github) 把luapanda_matser项目中/Debugger下的LuaPanda.lua文件拷贝到unity的lua工程根目录 在客户端Main.lua中新增 require(“LuaPanda”).start(“127.0.0.1”,8818) 增加启动配置launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"lua\", \"request\": \"launch\", \"tag\": \"normal\", \"name\": \"LuaPanda\", \"description\": \"通用模式,通常调试项目请选择此模式 | launchVer:3.2.0\", \"cwd\": \"${workspaceFolder}\", \"luaFileExtension\": \".lua\", \"pathCaseSensitivity\": true, \"connectionPort\": 8818, \"stopOnEntry\": false, \"useCHook\": true, \"autoPathMode\": true, \"logLevel\": 1 }, { \"type\": \"lua\", \"request\": \"launch\", \"name\": \"LuaPanda-Attach\" }, { \"type\": \"lua\", \"request\": \"launch\", \"tag\": \"independent_file\", \"name\": \"LuaPanda-IndependentFile\", \"description\": \"独立文件调试模式,使用前请参考文档\", \"luaPath\": \"\", \"packagePath\": [], \"luaFileExtension\": \".lua\", \"connectionPort\": 8818, \"stopOnEntry\": false, \"logLevel\": 1, \"useCHook\": true } ] } 启动debug调试，点运行和调试三角箭头。 看调试控制台内容 启动你的unity项目查看控制台是否已经建立 配置说明 launch.json 配置说明 launch.json 指的是存在于被调试项目的 .vscode/launch.json 文件，它保存调试器的运行配置，这里主要介绍各项配置项的含义，方便大家根据需要求改。 另外需要注意的是，调试器不同版本生成的 launch.json 文件可能会有所不同，如果升级后遇到问题，可以删除launch.json文件并重新生成。 下面是 3.2.0 版本的 launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"lua\", \"request\": \"launch\", \"tag\": \"normal\", \"name\": \"LuaPanda\", \"cwd\": \"${workspaceFolder}\", \"luaFileExtension\": \"\", \"connectionPort\": 8818, \"stopOnEntry\": true, \"useCHook\": true, \"autoPathMode\": true, }, { \"type\": \"lua\", \"request\": \"launch\", \"tag\": \"independent_file\", \"name\": \"LuaPanda-IndependentFile\", \"luaPath\": \"\", \"packagePath\": [], \"luaFileExtension\": \"\", \"connectionPort\": 8820, \"stopOnEntry\": true, \"useCHook\": true, } ] } launch.json 包含两个模式 LuaPanda 自适应模式 LuaPanda-IndependentFile 单文件调试模式 我们定义的自适应模式是一种最频繁使用的模式。有些调试器分为 launch 以及 attach 模式，我们理解 lua 是一种脚本语言，常嵌入 c# ， c++ 中被调用，通常在使用 lua 调试器时，用户会手动启动 unity / unreal，调试器无需再拉起这些被调试程序。如果有启动 vscode 调试器拉起一个二进制程序的需求，可以关注下面的 program 选项。 必要配置 项目 默认值 意义 type “lua” 插件适用于lua语言，请勿修改 request “launch” 因为我们使用自适应模式，保持launch不必修改 tag “normal” 可以选择normal(通用模式)，attach(附加模式)，区别是启动时是否自动拉起program配置指向的程序。不建议修改 name “LuaPanda” 展示在VScode运行按钮旁的目标名，3.2.0 后可根据需要自行修改 cwd “${workspaceFolder}” 被调试的包含lua目录，${workspaceFolder} 指 VScode 打开的目录，通常不用修改。即使要修改，也请用 “${workspaceFolder}/path” 这样的相对路径 luaFileExtension \"\" 重要设置： 用户设置的lua文件的后缀，如 txt , lua.txt 等 connectionPort 8818 默认端口号，如果连接无问题，可以不用修改。如果改了这里，请同步修改require(\"LuaPanda\").start(ip, port)中的端口号 stopOnEntry true 调试器建立连接后立刻停止。接入调试器时建议设置true, 稳定使用后可根据用户需要设置成 false useCHook true 运行时尝试加载 c 模块，这个模块作用是加速运行，加载不成功也不会影响调试效果 autoPathMode true 是否使用自动路径模式。强烈建议 true program \"\" 可以填入一个二进制文件路径，启动调试器会自动运行这个文件 扩展功能的可选配置 项目 默认值 意义 isNeedB64EncodeStr true 对传输的字符串使用 base64 加密，避免一些异常字符干扰协议解析 pathCaseSensitivity false 路径大小写敏感。默认 false 可兼容 getInfo获取的路径大小写，无需修改 updateTips true 当检查到项目中的 lua 文件比较旧时，提示用户升级 logLevel 1 日志等级，开发调试器时可能会使用0级，大量日志会降低运行效率。正常使用请勿修改 distinguishSameNameFile false 调试器默认不做同名文件区分 , 请不要在同名文件中打断点（此时仅依靠文件名进行文件区分）。如需要调试器区分同名文件，可尝试设置为 true，此时会执行较为严格的路径模式。 truncatedOPath \"\" 路径裁剪，通常无需修改。配合 distinguishSameNameFile: true 模式使用。裁减掉 getinfo 的一部分路径，用剩余的路径进行断点匹配 VSCodeAsClient false 反转 VScode 和 lua 进程的 C/S connectionIP “127.0.0.1” 配合 VSCodeAsClient: true 模式使用，要连接的 lua 进程所在ip LuaPanda-IndependentFile 模式的配置 LuaPanda-IndependentFile 我们称之为\"独立文件模式\" , 它的作用是打开一个新的终端，并 lua 命令运行当前 VSCode 活动窗口中的 lua 代码，并连接调试器，对其进行调试。 这个模式的目的是方便进行 lua 开发时，测试一些独立的文件 / 函数运行状况。 使用时请确保系统中安装了 lua 命令行二进制文件 以及 luasocket。测试方法是打开一个终端，运行 lua 看是否报错，之后尝试 require(\"socket.core\") 不报错即可使用。 单文件模式有一些独立的配置： 配置项 默认值 建议 luaPath \"\" Lua 可执行文件的路径，如果已经加入系统path路径，可以不用修改 packagePath [] 可以加入用户自己的packagepath路径，比如[\"./?.lua\", “../?.lua” ] ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:2:3","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"屏蔽某些后缀名文件 从顶部菜单栏打开文件-\u003e 首选项-\u003e 设置（或者使用快捷键Ctrl+，） 在设置页面的输入框中输入files:exclude 点击添加模式，输入 **/*.meta 即可 常用快捷键 查找引用：shift+f12 返回上一步：Alt+← 文件搜索：ctrl+p ","date":"2023-04-22","objectID":"/posts/unity3d_addvscode/:3:0","tags":["lua","vscode"],"title":"VSCode的安装与使用在untiy中","uri":"/posts/unity3d_addvscode/"},{"categories":["unity"],"content":"对应用程序进行性能分析、管理其内存以及彻底优化其功耗","date":"2022-10-18","objectID":"/posts/unity3d_profiler/","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"要想为玩家创造沉浸式游戏体验，流畅的性能至关重要。精益、高性能的代码和优化的内存使用可提高低端和高端设备的性能。总体而言，良好的性能会提高玩家体验的流畅感，从而提升留存率。 Unity 中文课堂上架了《游戏性能分析终极指南》，汇集了有关如何在 Unity 中对应用程序进行性能分析、管理其内存以及彻底优化其功耗的高级建议和知识。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:0:0","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"性能分析入门 在深入了解如何在 Unity 中对游戏进行性能分析的细节之前，让我们总结一些关键概念和性能分析原则。 各种性能分析器是开发者工具包中最有用的工具之一，用于识别代码中的内存和性能瓶颈。性能分析器可视为探测工具，帮助用户揭示应用程序性能滞后或代码分配过多内存的原因。 Unity 附带了各种性能分析工具，用于在编辑器和硬件上分析和优化用户的代码。我们还建议对每个目标平台使用原生性能分析工具，例如 Arm、Apple、PlayStation 和 Xbox 提供的工具。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:0","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"了解 Unity 中的性能分析 Unity 的性能分析工具可在编辑器中使用，并可通过 Package Manager 获得。 Unity Profiler：测量 Unity 编辑器、用户的应用程序在运行模式下，或在开发模式下连接到设备运行时的性能 Profiling Core 包：提供的 API 可用于将上下文信息添加到 Unity Profiler 捕获 Memory Profiler：提供深入的内存性能分析的工具 Profile Analyzer：将两个性能分析数据集进行比对，分析用户所做的更改如何影响应用程序的性能 “Unity 性能分析和调试工具”部分详细说明了如何使用这些工具以及帧调试器 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:1","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"基于样本的性能分析与基于检测的性能分析 有两种常用的游戏性能分析方法 ： 基于样本的性能分析 基于检测的性能分析 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:2","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"基于样本的性能分析 基于样本的性能分析对应用程序正进行的工作的统计数据进行收集并分析。 基于样本的性能分析器每隔“n”纳秒探测一次调用堆栈，并使用调用堆栈信息来确定函数何时被调用（以及由哪些函数调用），以及运行了多长时间。通过使用更高的采样率频率可以提高这种性能分析方法的准确性，因为对函数较短的调用也会在调用堆栈中捕捉到。但是，它会导致更高的开销。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:3","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"基于检测的性能分析器 基于检测的性能分析通过添加性能分析器标记来“检测”代码，这些标记记录有关每个标记中的代码执行多长时间的详细计时信息。此性能分析器捕获每个标记的 Begin和 End 事件流。此方法不会丢失任何信息，但它确实依赖于标记的放置以便捕获性能分析数据。 性能分析器： https://docs.unity3d.com/cn/current/Manual/profiler-markers.html Unity Profiler 是基于检测的。大多数 Unity API 表面中设置的标记实现了细节与开销的良好平衡。重要的原生功能和脚本代码库消息调用被用来捕获最重要的“大框架”，不会产生太多开销。 这使用户可以探查代码的性能，轻松定位性能问题，并快速发现优化位置 ；用户可以通过添加自定义性能分析器标记或使用深度性能分析来进一步分析。 深度性能分析会在每个脚本方法调用中自动插入 Begin 和 End 标记，包括 C# Getter和 Setter 属性。该系统在脚本侧提供了完整的性能分析详细信息，但它带来了相关的开销，从而导致报告的计时数据被夸大，具体取决于捕获的性能分析范围内的调用数量。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:4","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"Unity 中基于检测的性能分析 上面提到的脚本代码库消息调用（默认显式检测）通常包括从Unity 原生代码到托管代码的调用的第一个调用堆栈深度。比如常用的 MonoBehaviour 方法，如Start()、 Update()、FixedUpdate() 等。 性能分析示例脚本显示了 Update() 方法对 Unity Instantiate() 方法的调用示意图 \" 性能分析示例脚本显示了 Update() 方法对 Unity Instantiate() 方法的调用 用户还可以在 Profiler 中看到回调到 Unity API 的托管脚本代码的子示例。但是，需要注意的一点是，要检测的Unity API 代码本身需要具有检测性能分析器标记。大多数产生性能开销的 Unity API 都会被检测。例如，使用camera．main 将导致 FindMaincamera 标记出现在性能分析捕获中。在检查捕获的性能分析数据集时，了解不同标记的含义很有用。使用此常见性能分析器标记列表了解更多信息。 使用Camera．main 会导致 FindMainCamera 标记出现在性能分析捕获中示意图 \" 使用Camera．main 会导致 FindMainCamera 标记出现在性能分析捕获中 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:5","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"使用性能分析器标记增加性能分析细节 默认情况下，Unity Profiler 将对显式包含在性能分析器标记中的代码计时数据进行性能分析。手动将性能分析器标记插入到代码中的关键函数中，可以有效提高性能分析运行的详细程度，且不会导致深度性能分析的全部开销。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:6","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"性能分析器模块 Profiler 捕获每帧性能指标，以帮助用户找到瓶颈所在。使用 Profiler 中包含的性能分析器模块深入了解详细信息，例如 CPU Usage、GPU、Rendering、Memory、 Physics 等。 Profiler 主窗口视图，左侧显示模块，底部显示详细信息面板示意图 \" Profiler 主窗口视图，左侧显示模块，底部显示详细信息面板 Profiler 窗口在视图底部的面板中列出了使用当前选定的性能分析器模块捕获的详细信息。例如，CPU Usage Profiler 模块显示 CPU 工作的时间轴或层级视图以及具体时间。 CPU Usage 模块 Timeline 视图，显示 Main Thread 和 Render Thread 标记详细信息示意图 \" CPU Usage 模块 Timeline 视图，显示 Main Thread 和 Render Thread 标记详细信息 使用 Unity Profiler 评估应用程序的性能并深入探查具体范围和问题。默认情况下，Profiler 将连接到 Unity Editor Player 实例。 请注意，用户会发现在编辑器中进行性能分析与对独立构建进行性能分析之间存在很大差异。我们总是希望将 Profiler 连接到直接在目标硬件上运行的独立构建，因为这会产生最准确的结果，而无需编辑器开销。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:1:7","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"性能分析工作流程 本节确定了性能分析时的一些有用的目标。还着眼于常见的性能瓶颈，例如受 CPU 限制或 GPU 限制，并详细说明如何识别这些情况并更详细地进行探查。 最后，将深入研究内存性能分析，这在很大程度上与运行时性能无关，但很重要，因为它可以防止游戏崩溃。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:0","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"设置帧预算 从为玩家提供一致体验的角度，以每秒帧数 (fps) 为单位衡量游戏的帧率并不理想。我们考虑以下简化场景 ： 在运行时，用户的游戏在 0．75 秒内渲染 59 帧。但是，下一帧渲染需要 0．25 秒。尽管平均传输帧率 60 fps 听起来不错，但实际上玩家会注意到卡顿效果，因为最后一帧需要 1/4 秒才能渲染。 这就是为什么以每帧的特定时间预算为目标很重要的原因之一。这会为用户在性能分析和优化游戏时提供一个坚实的目标，并最终帮助用户为玩家创造更流畅、更一致的体验。 根据每秒目标帧数 (fps)，每一帧都有时间预算。如果应用程序以 30 fps 为目标，则每帧花费的时间应始终少于 33．33 ms (1000 ms / 30 fps)。如果目标为 60 fps，则每帧用时上限为 16．66 ms。 用户可以在非交互式序列期间超出此预算，例如，在显示 UI 菜单或场景加载时，但不能在游戏期间超出。即使一个帧超过了目标帧预算，也会导致卡顿。 在 VR 游戏中始终保持高帧率对于避免让玩家产生恶心感或不适至关重要。如果达不到要求，用户可能会在游戏认证期间被平台持有者拒绝。 每秒帧数 ：一个欺骗性的指标 游戏玩家衡量性能的常用方法是使用帧率或每秒帧数。但是，建议用户改用以毫秒为单位的帧时间。要了解其中的原因，请查看 fps 与帧时间的关系图。 fps 与帧时间示意图 \" fps 与帧时间 考虑这些数字： 1000 毫秒/秒 / 900 fps = 1.111 毫秒/帧 1000 毫秒/秒 / 450 fps = 2.222 毫秒/帧 1000 毫秒/秒 / 60 fps = 16.666 毫秒/帧 1000 毫秒/秒 / 56.25 fps = 17.777毫秒/帧 如果用户的应用程序以 900 fps 的速度运行，这将转换为每帧 1.111 毫秒的帧时间。在 450 fps 时，这是每帧 2.222 毫秒。这表示每帧仅相差 1.111 毫秒，即使帧率似乎下降了一半。 如果用户查看 60 fps 和 56.25 fps 之间的差异，则分别转换为每帧 16.666 毫秒和每帧 17.777 毫秒。这也代表每帧多出 1.111毫秒，但在这里，帧率下降的百分比感觉远没有那么显著。 这就是为什么开发者使用平均帧时间而不是 fps 来衡量游戏速度的原因。 除非用户低于目标帧率，否则不要担心 fps。专注于帧时间来衡量用户的游戏运行速度，然后保持在用户的帧预算范围内。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:1","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"移动设备的挑战 ：热控制和电池寿命 在为移动设备开发应用程序时，热控制是最重要的优化领域之一。如果CPU 或 GPU由于代码效率低下而花太多时间全速工作，就会导致芯片变热。为了避免损坏芯片（并可能烧伤玩家的手！），操作系统会降低设备的时钟速度以使其冷却，从而导致帧卡顿和糟糕的用户体验。这种性能降低称为热节流。 较高的帧率和增加的代码执行（或 DRAM 访问操作）会导致电池消耗和发热增加。糟糕的性能还可能导致在低端移动设备的整个细分市场被淘汰，从而导致错失市场机会。 在处理散热问题时，需将必要的预算视为系统范围的预算。 通过利用早期性能分析技术，第一时间对游戏进行优化，从而应对热节流和电池消耗。为用户的目标平台硬件接入用户的项目设置，以解决散热和电池消耗问题。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:2","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"在移动设备上调整帧预算 对于长时间游戏导致的设备散热问题，通常建议将帧空闲时间保留在 35% 左右。这使移动芯片有时间冷却下来， 并有助于防止过度消耗电池电量。目标帧时间每帧33.33 ms（对于 30 fps）时，移动设备的典型帧预算约为每帧 22 ms。 计算方式如下 ：（1000 ms ／ 30) * 0.65 = 21.66 ms 要使用相同的计算在移动设备上实现 60 fps，所需的目标帧时间为 (1000 ms / 60) * 0.65 = 10.83 ms。这在许多移动设备上很难实现，而且电池消耗的速度是目标 30 fps的两倍。由于这些原因，大多数手机游戏的目标是 30 fps 而不是 60。有关帧时间的更多详细信息，请使用 Application.targetFrameRate来控制该设置，并参考设置帧预算小节的内容。 在性能分析时，移动芯片上的频率调整会使识别帧空闲时间预算分配变得很棘手。用户的改进和优化可以产生正面影响，但移动设备可能会降低频率，从而运行温度更低。使用 FTrace 或 Perfetto等自定义工具，可以监控优化前后的移动芯片频率、空闲时间和缩放。 只要用户保持在目标 fps 的总帧时间预算内（33.33 ms，30 fps）内，并且看到设备保持此帧率时工作减少，或者记录到较低的温度，那么用户的做法就是正确的。 使用 FTrace 或 Perfetto 等工具监控 CPU 频率和空闲状态，以帮助识别帧预算余量优化的结果。示意图 \" 使用 FTrace 或 Perfetto 等工具监控 CPU 频率和空闲状态，以帮助识别帧预算余量优化的结果。 为移动设备的帧预算增加冗余空间的另一个原因是考虑到现实世界的温度波动。在炎热的天气里，移动设备会发热并且散热困难，这可能会导致热节流和游戏性能不佳。预留一定百分比的帧预算将有助于避免此类情况。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:3","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"减少内存访问操作 在移动设备上，DRAM 访问通常是耗电的操作。Arm 针对移动设备上的图形内容的优化建议称，LPDDR4 内存访问成本约为每字节 100 皮焦耳。 通过以下方式减少每帧的内存访问操作数 ： 降低帧率 尽可能降低显示分辨率 使用更简单的网格，减少顶点数和属性精度 使用纹理压缩和 Mipmap 当用户需要关注使用 Arm 或 Arm Mali 硬件的设备时，Arm Mobile Studio 工具（具体而言就是 Streamline Performance Analyzer）包含一些出色的性能计数器，用于识别内存带宽问题。针对每一代 Arm GPU（例如 Mali-G78）列出了计数器并进行解释。请注意，Mobile Studio GPU 性能分析需要 Arm Mali。 Arm 的 Streamline Performance Analyzer 包含大量性能计数器信息，可以在目标 Arm 硬件上的实时性能分析会话期间捕获这些信息。这对于识别过度绘制导致的内存带宽饱和等性能问题非常有用。示意图 \" Arm 的 Streamline Performance Analyzer 包含大量性能计数器信息，可以在目标 Arm 硬件上的实时性能分析会话期间捕获这些信息。这对于识别过度绘制导致的内存带宽饱和等性能问题非常有用。 ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:4","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"建立基准测试的硬件层级 除了使用特定于平台的性能分析工具之外，还可以为用户希望支持的每个平台和质量等级建立层级或一个最低规格的设备，然后针对这些规格中的逐一进行性能分析和优化。 例如，如果用户的目标是移动平台，用户可能会决定支持具有质量控制的三层，这些质量控制会根据目标硬件打开或关闭功能。然后，用户针对每一层中的最低设备规格进行优化。再举一个例子，如果用户正在为 PlayStation 4 和 PlayStation 5 开发游戏，请确保对两者都进行了性能分析。 Written with StackEdit. ","date":"2022-10-18","objectID":"/posts/unity3d_profiler/:2:5","tags":["Profiler","unity"],"title":"Unity游戏性能分析指南","uri":"/posts/unity3d_profiler/"},{"categories":["unity"],"content":"有几个特定的项目设置会影响移动端游戏的性能。","date":"2022-10-13","objectID":"/posts/unity3d_projectsetting/","tags":["unity"],"title":"Unity项目配置建议","uri":"/posts/unity3d_projectsetting/"},{"categories":["unity"],"content":"有几个特定的项目设置会影响移动端游戏的性能。 降低或禁用Accelerometer Frequency（加速度计频率） Unity每秒钟会以一定次数统计移动设备的加速度计状态。如果应用并不会用到加速度计，我们完全可以禁用该功能或降低统计频率来获得更好的性能。 请在游戏不使用加速度计时禁用Accelerometer Frequency。 禁用不必要的Player或Quality设置 如果目标平台并不支持Auto Graphics API，最好禁用Player设置中的相应选项，防止驱动程序生成多余的着色器变体。如果应用不支持老式CPU，请禁用Target Architectures 。 禁用Quality设置里多余的质量等级。 禁用不必要的物理模拟 如果游戏并不会用到物理模拟，请取消勾选Auto Simulation和Auto Sync Transforms。这两个选项在物理模拟之外并没有过多的用处，因此只会减缓应用的运行。 选择正确的帧率 移动端项目必须小心在帧率与电池寿命、过热保护间找到平衡。有时与其用60帧挑战设备的极限，用30帧平稳运行是一种更好的选择，Unity默认会将移动端应用的帧率设为30fps。 你也可以在运行时调用Application.targetFrameRate动态地调整帧率，比如，在相对较慢或静止的场景中将帧数降到30帧以下，在游戏进行中保留高帧数。 消除庞杂的对象层级 把对象层级拆开。如果某个GameObjects不需要嵌到层级里，我们可以简化对象的从属关系。更精简的对象层级可以很好地利用多线程处理来刷新对象的Transform，而复杂的层级结构会导致多余的Transform计算和更高的垃圾数据回收成本。 关于Transform的最佳设置方法，请在Optimizing the Hierarchy和这段Unite演讲中详细了解。 尽量一次完成对象变换 在移动Transform时，请调用Transform.SetPositionAndRotation一次性完成对象的移动和旋转，这样做可避免两次修改同一变换，节省运算开销。 如果你需要在运行时实例化一个GameObject，则可以在实例化之际嵌入并移动对象，来达到优化的目的： GameObject.Instantiate(prefab, parent); GameObject.Instantiate(prefab, parent, position, rotation); 关于Object.Instantiate的更多细节，请参见Scripting API。 Vsync 在移动平台上默认启用 大部分移动端设备并不会将图像帧一分为二进行渲染。但即便我们在编辑器选项中禁用Vsync（Project Settings \u003e Quality），Vsync功能仍会在硬件层面上启用。因为如果GPU频率不够高，帧将被滞留直到渲染完成，导致帧数降低。 Written with StackEdit. ","date":"2022-10-13","objectID":"/posts/unity3d_projectsetting/:0:0","tags":["unity"],"title":"Unity项目配置建议","uri":"/posts/unity3d_projectsetting/"},{"categories":["unity"],"content":"尝试优化 Unity 音频","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"虽然音频通常不会产生性能瓶颈，但一定的优化仍然可以省下些许内存。 优化AudioClips（音频片段）的导入设置。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/:0:0","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"尽可能地采用未经压缩的原始WAV文件作为资源 Unity会在导入时解压所有的压缩格式（如MP3或Vorbis），在构建时再度进行压缩，这就导致了音频经受两次压缩，最终音质将不可避免地受损。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/:0:1","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"降低音频压缩时的压缩比 当然，我们的确能使用压缩技术来降低音频大小和内存使用： Vorbis格式适用于大部分音效（不用循环播放的音效可使用MP3）。 ADPCM格式适用于短促且经常出现的声音（如脚步声、枪声）。相较于未压缩的PCM格式，该格式减小了文件体积，还能在播放时快速解码。 移动设备上的声效最高频率应为22,050赫兹，较低的频率虽然对最终音频的影响不大，但你最好用自己的双耳来做判断。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/:0:2","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"选择恰当的Load Type（加载类型） Load Type设置应根据音频的体积而异。 **短音频（\u003c 200 kb）可以设为Decompress on Load（加载时解压），**这时音频会被解压成原始的16位PCM音频数据，产生一定CPU和内存占用，所以音频不宜过大。 中等音频（\u003e=200kb）可保持Compressed in Memory（在内存中压缩）。 长音频（背景音乐）应设为Streaming（流播放），避免将整个音频资源一次性加载到内存中。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/:0:3","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"释放无声音AudioSources的内存 如果游戏中有静音按钮，静音行为不能只是简单地将音量设置为0。假设玩家无需经常性地开关静音，我们可以调用Destroy方法来将AudioSource组件从内存中移除。 Written with StackEdit. ","date":"2022-10-13","objectID":"/posts/untiy3d_unityaudiodo/:0:4","tags":["unityAudio","unity"],"title":"Unity音频优化Tip","uri":"/posts/untiy3d_unityaudiodo/"},{"categories":["unity"],"content":"尝试优化 Unity 资源","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"资源管线会极大地影响应用的性能。因此，我们最好请一名经验丰富的技术美术来协助制定和实施资源的格式、规格和导入设置，让流程尽可能流畅。 请不要完全依赖默认设置，使用具体平台的重写组件来优化纹理、网格几何形等资源。错误的资源设置可能会导致游戏文件过大、构建时间过长，甚至造成不合理的内存占用。请灵活使用Presets（预设）功能来制定适合项目的设置基准。 更多详情请参阅这份美术资源最佳使用指南，或在Unity Learn上学习3D Art Optimization for Mobile Applications教程。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:0","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"找到正确的纹理导入方式 一款应用的大部分内存占用一般是用在了纹理上，因此纹理的导入设置非常关键。通常来说，纹理的导入应遵守如下原则： **降低最大分辨率：**在肉眼不易察觉、尽量不破坏原图的前提下使用较低的分辨率，从而达到优化内存占用的目的。 **采用二次幂（power of two，POT）压缩格式：**Unity要求移动端的纹理压缩格式（PVRCT或ETC）采用二次幂的纹理尺寸。 **制作纹理图集（texture atlas）：**将多张纹理合并到一张纹理图集中可以减少绘制调用次数，加快渲染速度。纹理图集可使用Unity Sprite Atlas或第三方的TexturePacker 进行制作。 取消勾选Read/Write Enabled：该选项在启用时会分别在CPU和GPU可寻址内存中创建一个副本，让纹理的内存占用翻倍。该选项在大多数情况下都可禁用。如果纹理是在运行时生成的，则可通过调用Texture2D.Apply，将makeNoLongerReadable设为true来强制禁用选项。 **禁用多余的Mip Map：**Mip Map贴图在2D精灵和UI图形这类大小始终一致的纹理上并无用处，但在随镜头距离变化而变化的3D模型上需要保留。 正确的纹理导入设置可以优化应用包的大小。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:1","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"压缩纹理 我们来对比一下两个模型和纹理相同的例子：左图所占用的内存几乎是右图的八倍，但在视觉上却没有什么不同。 未经压缩的纹理会占用更多的内存。 因此，请为iOS和Android应用采用自适应可伸缩纹理压缩（ATSC）格式。大多数游戏在开发时都以支持ATSC压缩、配置最低的设备作为目标设备。 当然也有例外，包括： 运行于A7及更老的芯片上的iOS游戏（即iPhone 5、5S等）——请使用PVRTC格式 运行于2016年以前的安卓设备的安卓游戏——请使用 ETC2 （爱立信的纹理压缩格式） 如果PVRTC和ETC等压缩格式的质量不够理想，或者目标设备不完全支持ASTC格式，我们可以试着将32位纹理替换成16位纹理。 请在完整版手册中详细了解各平台推荐的纹理压缩格式。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:2","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"调整网格导入设置 类似于纹理，网格模型如果导入不当，也会占用过多的内存。要想尽量减少网格模型的内存占用，我们可以： 压缩网格，采用激进的压缩方法来减少磁盘空间占用（运行时的占用不会受影响）。注意，量化模型可能会导致模型失真，请根据实际情况来选择合适的压缩等级。 禁用Read/Write，该选项会分别在运行内存和GPU内存中创建模型的副本，它在大多数情况下都应禁用（Unity 2019.2及更早的版本会默认启用）。 禁用动画骨架和BlendShapes，若网格模型不带有骨骼动画或BlendShapes动画，则这两个选项并无多大用处。 禁用法线和切线贴图，若网格模型的材质并没有法线或切线贴图，则我们能禁用这两个选项来节省性能开支。 请仔细检查网格模型的导入设置。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:3","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"检查模型多边形面数 一个模型如果有更高的分辨率就意味着更多的内存占用和更长的GPU处理时间。通常来说，游戏的背景并不需要数十万的面，并且许多DCC软件导出的模型也可做一定的精简。举例来说，处于摄影机拍摄角之外的多边形可被删去，模型的细节可使用纹理和法线贴图呈现，不必使用过于复杂的网格来保留细节。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:4","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"借助AssetPostprocessor自动设定导入设置 AssetPostprocessor功能支持在导入资源时运行脚本，如此一来我们便能在模型、纹理、音频等资源的导入前/后应用自定义设置。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:5","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"使用Addressable Asset System（可寻址资源系统） Addressable Asset System可以一种更为简单的方式来管理内容。系统采用统一的处理方式，通过调用AssetBundle的“地址”或别称，从本地路径或远程的内容分发网络（CDN）异步完成资源的加载。 如果把脚本以外的资源（模型、纹理、预制件、音频，甚至整个场景）划分成一个个AssetBundle，就可以将其作为可下载内容（DLC）分开分发。 然后，使用Addressables创建一个最小的应用程序，Cloud Content Delivery将在游戏进行中完成游戏内容的管理和分发。 使用“地址”来加载资源。 点击此处来详细了解Addressable Asset System是怎样让资源管理更为轻松的。 Written with StackEdit. ","date":"2022-10-13","objectID":"/posts/untiy3d_unityartdo/:0:6","tags":["unityArt","unity"],"title":"Unity资源优化建议","uri":"/posts/untiy3d_unityartdo/"},{"categories":["unity"],"content":"尝试优化 Unity UI提高性能","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"分割Canvas画布 如果某个大型Canvas包含了上千个元素，单个UI元素的更新也会导致整个Canvas更新，造成不必要的CPU占用。 这时我们可利用UGUI的多画布功能，根据更新频率来划分UI元素。将相对静止的UI元素放在一个画布上，将需要时常更新的动态元素放在小型的子画布上， 然后统一画布内所有UI元素的Z轴坐标、材质和纹理。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:1","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"隐藏不可见的UI元素 部分UI元素可能只会间断地出现（譬如角色受伤时出现的血条），就算这个元素变得不可见，它仍可能会发出绘制调用。因此我们需要具体地禁用所有不可见的UI组件，仅在需要时重新激活。 如果你只需隐藏画布，可以禁用Canvas组件，不必禁用整个GameObject，从而避免引擎再度绘制网格和顶点。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:2","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"限制GraphicRaycasters数量、禁用Raycast Target 类似屏幕触摸或点击等输入事件需要使用GraphicRaycaster组件处理。组件会循环检测屏幕的每个输入点，检查其与UI的RectTransform是否有重叠。 但我们不必将GraphicRaycaster放在默认Canvas层级的顶层，而可以将其添加到需要互动的元素（按钮、滚动条等等）上。 此外，不一定每个UI文本都要为Raycast Target（射线目标）。在不必要的位置禁用这个选项可让UI运算进一步简化，这在复杂的UI上意味着不小的性能收益。 如无必要，请禁用Raycast Target。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:3","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"避免使用Layout Group（布局组） 由于Layout Group的更新效率较低，所以非动态内容完全可以不使用这项功能，转而借助锚点来实现比例化布局。或者，你也能用自定义代码在布局生成完毕后禁用Layout Group组件。 如果你确实需要在动态元素上使用（水平、垂直、网格式）Layout Group，请避免嵌套使用。 Layout Group，尤其是在嵌套使用时，可能会显著降低性能。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:4","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"避免使用大型的List与Grid视图 大型List和Grid视图会占用大量性能。如果你需要创建一个大型的List或Grid视图（比如一个包含数百个物品的物品栏），可以考虑建立一个UI库，重复使用库中的元素而非为每个物品创建一个元素。请在这个GitHub项目样例中查看实例。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:5","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"避免多元素的重叠 将大量的UI元素堆在一起（比如卡牌游戏中的卡堆）会造成过度绘制。我们可使用自定义代码，在运行时将堆叠的多个元素合并成几个或几批较小的元素。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:6","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"使用多种分辨率和长宽比 目前移动设备的分辨率和屏幕尺寸五花八门，而制作不同分辨率的UI、让其完美适配设备也就很有必要了。 Device Simulator（设备模拟器）支持在引擎中模拟UI在各个设备上的表现。你也可以使用XCode和Android Studio来创建虚拟设备。 在Device Simulator中预览各种样式的屏幕。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:7","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"在UI覆盖全屏时隐藏不可见内容 如果暂停或开始菜单覆盖了整个场景，我们可以禁用渲染场景的摄像机，同样地，隐藏在顶层画布背后的元素也可被禁用。 你甚至可以在UI显示期间使用Application.targetFrameRate来降低帧率，因为UI不需要以高帧率刷新。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:8","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"在游戏空间与Camera Space Canvas上摆放摄像机 如果Event或Render Camera字段为空，则Unity会强行在其中加入Camera.main，造成不必要的性能浪费。 我们可以使用在画布的RenderMode中使用Screen Space - Overlay，来省略掉摄像机的使用。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityuido/:0:9","tags":["ugui","unity"],"title":"如何优化UnityUI","uri":"/posts/untiy3d_unityuido/"},{"categories":["unity"],"content":"尝试优化 Unity UI 系统","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"尝试优化 Unity UI 系统之前的主要任务是找出观察到的性能问题的确切原因。 Unity UI 用户遇到的常见问题有四类： Gpu片段着色器使用过多（填充率过度使用） 重建Canvas批处理所花费的CPU时间过多 Canvas批次的重建数量过多 用于生成顶点的CPU时间过多 界面源代码 永远记住，Unity UI 的图形和布局组件是完全开源的。他们的源代码可以在Unity 的 Bitbucket 存储库的的UI下找到。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:0:0","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"Unity UI 基础知识 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:1:0","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"渲染细节 在unityui中编写用户界面时，所有由canvas绘制的几何图形都将在透明队列中绘制，也就是说，unityui生成的几何图形始终使用alpha混合从后到前绘制，从性能角度来看，记住重要一点，从多边形栅格化的每个像素都将被采样，即使他完全被不透明的多边形覆盖，在移动设备上，这种高水平的过度绘制会迅速超过GPU的填充率容量。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:1:1","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"批量构建过程（画布） 批处理构建过程是Canvas组合表示其UI元素的网格并生成适当的渲染命令以发送到unity的图形管道的过程，此过程的结果将被缓存并重用，直到canvas被标记为脏，只要其组成网格之一发生更改，就会发生这种情况。 画布使用的网格取自附加到画布但不包含在任何子画布中的一组画布渲染器组件。 计算批次需要按深度对网格进行排序，并检查他们是否存在重叠、共享材料等。此操作是多线程的，因此其性能在不同的CPU架构之间通常会有很大的差异，尤其是在移动SOC（通常只有很少的cpu内核）和现代桌面cpu（通常4个或更多内核）之间。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:1:2","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"重建过程（图形） 重建过程是重新计算unityui的c#图形组件的布局和网格的地方。这是在CanvasUpdateRegistry类中执行的。请记住，这是一个c#类，源码可在Bitbucket上找到 PerformUpdate 运行一个三步过程： 通过ICanvasElement.Rebuild方法请求脏布局组件重建其布局。 任何已注册的 Clipping 组件（例如 Masks）都被要求剔除任何被剪裁的组件。这是通过 ClippingRegistry.Cull 完成的。 脏图形组件被要求重建它们的图形元素。 对于布局和图形重建，该过程分为多个部分。布局重建分三部分（PreLayout、Layout和PostLayout）运行，而图形重建分两个部分（PreRender和LatePreRender）运行。 布局重建 要重新计算包含在一个或多个布局组件中的组件的适当位置（以及可能的大小），有必要以适当的分层顺序应用布局。在 GameObject 层次结构中更接近根的布局可能会改变可能嵌套在其中的任何布局的位置和大小，因此必须首先计算。 为此，Unity UI 按其在层次结构中的深度对脏布局组件列表进行排序。层次结构中较高的项目（即具有较少父变换的项目）被移动到列表的前面。 然后请求布局组件的排序列表来重建它们的布局；这是由 Layout 组件控制的 UI 元素的位置和大小实际改变的地方。有关单个元素的位置如何受布局影响的更多详细信息，请参阅 Unity 手册的UI 自动布局部分 图形重建 重建 Graphic 组件时，Unity UI 将控制权传递给ICanvasElement接口的Rebuild方法。Graphic 实现了这一点，并在重建过程的 PreRender 阶段运行两个不同的重建步骤。 如果顶点数据已被标记为脏（例如，当组件的 RectTransform 已更改大小时），则重新构建网格。 如果材质数据已被标记为脏（例如，当组件的材质或纹理已更改时），则附加的 Canvas Renderer 的材质将被更新。 图形重建不以任何特定顺序通过图形组件列表进行，并且不需要任何排序操作。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:1:3","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"填充率、画布和输入 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:0","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"修复填充率问题 可以采取两种措施来减少 GPU 片段管道上的压力： 降低片段着色器的复杂性。有关详细信息，请参阅“UI 着色器和低规格设备”部分。 减少必须采样的像素数。 由于 UI 着色器通常是标准化的，因此最常见的问题就是过度使用填充率。这通常是由于大量重叠的 UI 元素和/或具有占据屏幕重要部分的多个 UI 元素。这两个问题都可能导致极高水平的透支。 为了减轻填充率过度使用并减少透支，请考虑以下可能的补救措施。 消除不可见的 UI 需要对现有 UI 元素进行最少重新设计的方法是简单地禁用对玩家不可见的元素。这适用的最常见情况是打开具有不透明背景的全屏 UI。在这种情况下，可以禁用放置在全屏 UI 下方的任何 UI 元素。 最简单的方法是禁用包含不可见 UI 元素的根 GameObject 或 GameObjects。有关替代解决方案，请参阅禁用画布部分。 最后，通过将 alpha 设置为 0 来确保没有隐藏任何 UI 元素，因为该元素仍将被发送到 GPU 并且可能需要宝贵的渲染时间。如果 UI 元素不需要 Graphic 组件，您只需将其移除，光线投射仍然可以工作。 简化 UI 结构 为了减少重建和渲染 UI 所需的时间，尽可能减少 UI 对象的数量很重要。尽可能多地烤东西。例如，不要使用混合游戏对象来改变元素的色调，而是通过材质属性来做到这一点。另外，不要创建像文件夹一样的游戏对象，并且除了组织场景之外没有其他目的。 禁用隐形相机输出 如果打开具有不透明背景的全屏 UI，世界空间相机仍将渲染 UI 后面的标准 3D 场景。渲染器不知道全屏 Unity UI 会遮挡整个 3D 场景。 因此，如果打开一个完全全屏的 UI，禁用任何和所有被遮挡的世界空间相机将有助于通过简单地消除渲染 3D 世界的无用工作来减轻 GPU 压力。 如果 UI 没有覆盖整个 3D 场景，您可能希望将场景渲染为纹理一次并使用它，而不是连续渲染它。您将无法在 3D 场景中看到动画内容，但这在大多数情况下应该是可以接受的。 注意：如果 Canvas 设置为“Screen Space – Overlay” ，则无论场景中活动的摄像机数量如何，都会绘制它。 多数被遮挡的相机 许多“全屏”用户界面实际上并没有掩盖整个 3D 世界，而是让世界的一小部分可见。在这些情况下，仅捕获渲染纹理中可见的世界部分可能更理想。如果世界的可见部分被“缓存”在渲染纹理中，则可以禁用实际的世界空间相机，并且可以在 UI 屏幕后面绘制缓存的渲染纹理以提供 3D 世界的冒名顶替版本。 基于合成的 UI 设计师通过组合来创建 UI 是很常见的——组合和分层标准背景和元素以创建最终的 UI。虽然这样做相对简单，并且对迭代非常友好，但由于 Unity UI 使用透明渲染队列，它的性能不佳。 考虑一个带有背景、按钮和按钮上的一些文本的简单 UI。因为透明队列中的对象是从后到前排序的，如果一个像素落在文本字形中，GPU 必须采样背景纹理，然后是按钮纹理，最后是文本图集的纹理，总共三个样品。随着 UI 复杂性的增加，以及更多的装饰元素被叠加到背景上，样本的数量会迅速增加。 如果发现大型 UI 受填充率限制，最好的办法是创建专门的 UI 精灵，将 UI 的尽可能多的装饰/不变元素合并到其背景纹理中。这减少了为实现所需设计而必须相互叠加的元素数量，但劳动密集型并增加了项目纹理图集的大小。 这种将创建给定 UI 所需的分层元素的数量压缩到专门的 UI sprite 上的原则也可以用于子元素。考虑一个带有产品滚动窗格的商店 UI。每个产品 UI 元素都有一个边框、一个背景和一些图标来表示价格、名称和其他信息。 商店 UI 将需要背景，但由于其产品在背景中滚动，产品元素无法合并到商店 UI 的背景纹理中。但是，产品的UI元素的边框、价格、名称等元素可以合并到产品的背景上。根据图标的大小和数量，填充率的节省可能相当可观。 组合分层元素有几个缺点。专业元素不能再重复使用，需要额外的艺术家资源来创建。添加大型新纹理可能会显着增加保存 UI 纹理所需的内存量，尤其是在 UI 纹理不是按需加载和卸载的情况下。 UI 着色器和低规格设备 Unity UI 使用的内置着色器包含对遮罩、剪辑和许多其他复杂操作的支持。由于这种增加的复杂性，与 iPhone 4 等低端设备上更简单的 Unity 2D 着色器相比，UI 着色器的性能较差。 如果针对低端设备的应用程序不需要遮罩、裁剪和其他“花哨”功能，则可以创建一个省略未使用操作的自定义着色器，例如这个最小的 UI 着色器： Shader \"UI/Fast-Default\" { Properties { [PerRendererData] _MainTex (\"Sprite Texture\", 2D) = \"white\" {} _Color (\"Tint\", Color) = (1,1,1,1) } SubShader { Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"PreviewType\"=\"Plane\" \"CanUseSpriteAtlas\"=\"True\" } Cull Off Lighting Off ZWrite Off ZTest [unity_GUIZTestMode] Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" #include \"UnityUI.cginc\" struct appdata_t { float4 vertex : POSITION; float4 color : COLOR; float2 texcoord : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; fixed4 color : COLOR; half2 texcoord : TEXCOORD0; float4 worldPosition : TEXCOORD1; }; fixed4 _Color; fixed4 _TextureSampleAdd; v2f vert(appdata_t IN) { v2f OUT; OUT.worldPosition = IN.vertex; OUT.vertex = mul(UNITY_MATRIX_MVP, OUT.worldPosition); OUT.texcoord = IN.texcoord; #ifdef UNITY_HALF_TEXEL_OFFSET OUT.vertex.xy += (_ScreenParams.zw-1.0)*float2(-1,1); #endif OUT.color = IN.color * _Color; return OUT; } sampler2D _MainTex; fixed4 frag(v2f IN) : SV_Target { return (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color; } ENDCG } } ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:1","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"UI 画布重建 要显示任何 UI，UI 系统必须为屏幕上表示的每个 UI 组件构建几何图形。这包括运行动态布局代码、生成多边形来表示 UI 文本字符串中的字符，以及将尽可能多的几何图形合并到单个网格中以最小化绘制调用。这是一个多步骤的过程，在本指南开头的基础部分中有详细描述。 画布重建可能会成为性能问题，主要原因有两个： 如果 Canvas 上的可绘制 UI 元素的数量很大，那么计算批次本身就会变得非常昂贵。这是因为排序和分析元素的成本与 Canvas 上可绘制 UI 元素的数量成线性增长。 如果 Canvas 经常被弄脏，那么可能会花费过多的时间来刷新一个变化相对较少的 Canvas。 随着 Canvas 上元素数量的增加，这两个问题都会变得更加严重。 重要提醒：每当给定 Canvas 上的任何可绘制 UI 元素发生变化时，Canvas 必须重新运行批处理构建过程。此过程重新分析 Canvas 上的每个可绘制 UI 元素，无论它是否已更改。请注意，“更改”是影响 UI 对象外观的任何更改，包括分配给精灵渲染器的精灵、变换位置和比例、文本网格中包含的文本等。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:2","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"子订单 Unity UI 是从后到前构建的，对象在层次结构中的顺序决定了它们的排序顺序。层次结构中较早的对象被视为层次结构中较晚的对象。通过从上到下遍历层次结构并收集所有使用相同材质、相同纹理且没有中间层的对象来构建批次。“中间层”是具有不同材质的图形对象，其边界框与两个其他可批处理对象重叠，并放置在两个可批处理对象之间的层次结构中。中间层迫使批次被破坏。 正如 Unity UI 分析工具步骤中所讨论的，UI 分析器和帧调试器可用于检查 UI 的中间层。这是一种情况，其中一个可绘制对象将自己插入到另外两个可批处理的可绘制对象之间。 这个问题最常发生在文本和精灵彼此靠近时：文本的边界框可以不可见地与附近的精灵重叠，因为文本字形的大部分多边形是透明的。这可以通过两种方式解决： 重新排序可绘制对象，使可批处理对象不会被不可批处理对象插入；即，将不可批处理对象移动到可批处理对象的上方或下方。 调整对象的位置以消除不可见的重叠空间。 这两个操作都可以在 Unity 编辑器中执行，同时打开并启用 Unity 框架调试器。通过简单地观察 Unity Frame Debugger 中可见的绘制调用数量，可以找到一个顺序和位置，以最大限度地减少由于重叠 UI 元素而浪费的绘制调用数量。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:3","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"分割画布 除了最琐碎的情况外，通过将元素移动到子画布或兄弟画布来拆分画布通常是一个好主意。 兄弟画布最适合用于 UI 的某些部分必须与 UI 的其余部分分开控制其绘制深度的情况，以始终位于其他层之上或之下（例如教程箭头）。 在大多数其他情况下，子画布更方便，因为它们从父画布继承显示设置。 乍一看，将 UI 细分为多个子画布似乎是一种最佳实践，但请记住，画布系统也不会跨单独的画布组合批次。高性能 UI 设计需要在最小化重建成本和最小化绘制调用浪费之间取得平衡。 一般准则 因为 Canvas 会在其任何组成的可绘制组件发生更改时重新批处理，所以通常最好将任何非平凡的 Canvas 拆分为至少两个部分。此外，如果预计元素会同时发生变化，最好尝试将元素放在同一个 Canvas 上。一个例子可能是进度条和倒数计时器。它们都依赖于相同的基础数据，因此需要同时更新，因此它们应该放在同一个 Canvas 上。 在一个 Canvas 上，放置所有静态不变的元素，例如背景和标签。这些将在 Canvas 首次显示时批处理一次，然后不再需要重新批处理。 在第二个画布上，放置所有“动态”元素——那些经常变化的元素。这将确保此 Canvas 主要重新批处理脏元素。如果动态元素的数量变得非常大，则可能需要将动态元素进一步细分为一组不断变化的元素（例如进度条、计时器读数、任何动画）和一组仅偶尔变化的元素。 这在实践中实际上是相当困难的，尤其是在将 UI 控件封装到预制件中时。许多 UI 选择通过将更昂贵的控件拆分到子画布上来细分画布。 Unity 5.2 和优化的批处理 在 Unity 5.2 中，批处理代码被大幅重写，与 Unity 4.6、5.0 和 5.1 相比，其性能要高得多。此外，在多于 1 个内核的设备上，Unity UI 系统会将大部分处理移至工作线程。一般来说，Unity 5.2 减少了将 UI 积极拆分为数十个子画布的需要。现在，移动设备上的许多 UI 只需两个或三个 Canvas 即可实现高性能。 有关 Unity 5.2 优化的更多信息，请参阅此博客文章。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:4","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"Unity UI 中的输入和光线投射 默认情况下，Unity UI 使用Graphic Raycaster组件来处理输入事件，例如触摸事件和指针悬停事件。这通常由独立输入管理器组件处理。尽管有这个名字，Standalone Input Manager 是一个“通用”输入管理器系统，可以处理指针和触摸。 移动设备上的错误鼠标输入检测 (5.3) 在 Unity 5.4 之前，只要当前没有可用的触摸输入，每个附加了 Graphic Raycaster 的活动 Canvas 将每帧运行一次 raycast 以检查指针的位置。无论平台如何，都会发生这种情况；没有鼠标的 iOS 和 Android 设备仍会查询鼠标的位置，并尝试发现哪些 UI 元素位于该位置下方，以确定是否需要发送任何悬停事件。 这是对 CPU 时间的浪费，并且已经看到消耗了 Unity 应用程序 CPU 帧时间的 5% 或更多。 这个问题在 Unity 5.4 中得到解决。从 5.4 开始，没有鼠标的设备将不会查询鼠标位置，也不会执行不必​​要的光线投射。 如果使用低于 5.4 的 Unity 版本，强烈建议移动开发人员创建自己的 Input Manager 类。这可以像从 Unity UI 源复制 Unity 的标准输入管理器并注释掉 ProcessMouseEvent 方法以及对该方法的所有调用一样简单。 光线投射优化 Graphic Raycaster 是一个相对简单的实现，它遍历所有将“Raycast Target”设置为 true 的 Graphic 组件。对于每个 Raycast Target，Raycaster 执行一组测试。如果一个 Raycast 目标通过了所有的测试，那么它就会被添加到命中列表中。 Raycast 实现细节 测试是： 如果 Raycast Target 处于活动状态、启用并已绘制（即具有几何图形） 如果输入点位于 Raycast Target 所附加到的 RectTransform 内 如果 Raycast Target 具有或是任何ICanvasRaycastFilter组件的子级（在任何深度），并且该 Raycast Filter 组件允许 Raycast。 命中的 Raycast Targets 列表然后按深度排序，过滤反向目标，并过滤以确保移除在相机后面渲染的元素（即在屏幕中不可见）。 如果在 Graphic Raycaster 的“Blocking Objects”属性上设置了相应的标志，Graphic Raycaster 也可以将光线投射到 3D 或 2D 物理系统中。（从脚本中，该属性被命名为blockingObjects。） 如果启用了 2D 或 3D 阻挡对象，则在阻挡光线投射的物理层上的 2D 或 3D 对象下方绘制的任何光线投射目标也将从命中列表中删除。 然后返回最终的命中列表。 光线投射优化技巧 鉴于所有 Raycast Target 都必须由 Graphic Raycaster 测试，最佳实践是仅在必须接收指针事件的 UI 组件上启用“Raycast Target”设置。Raycast Targets 列表越小，必须遍历的层次越浅，每次 Raycast 测试的速度就越快。 对于具有多个必须响应指针事件的可绘制 UI 对象的复合 UI 控件，例如希望其背景和文本都更改颜色的按钮，通常最好将单个 Raycast Target 放置在复合 UI 的根部控制。当单个 Raycast Target 接收到一个指针事件时，它可以将事件转发到复合控件中的每个感兴趣的组件。 层次深度和光线投射过滤器 在搜索光线投射过滤器时，每个图形光线投射都会遍历变换层次结构一直到根。此操作的成本与层次结构的深度成比例线性增长。必须测试附加到层次结构中每个 Transform 的所有组件，以查看它们是否实现ICanvasRaycastFilter，因此这不是一个便宜的操作。 有几个标准的 Unity UI 组件使用ICanvasRaycastFilter，例如CanvasGroup、Image、Mask和RectMask2D，因此不能轻易消除这种遍历。 子画布和 OverrideSorting 属性 Sub-canvas 上的overrideSorting属性将导致 Graphic Raycast 测试停止爬升变换层次结构。如果可以启用它而不会导致排序或光线投射检测问题，那么应该使用它来降低光线投射层次遍历的成本。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:2:5","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"5.优化UI控件 优化 Unity UI 指南的这一部分侧重于特定类型的 UI 控件的问题。虽然大多数 UI 控件在性能方面都比较相似，但有两个是导致游戏接近可交付状态时遇到的许多性能问题的原因。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:3:0","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"用户界面文本 Unity 的内置文本组件是一种在 UI 中显示光栅化文本字形的便捷方式。然而，有许多行为并不为人所知，但经常作为性能热点出现。在向 UI 添加文本时，请始终记住，文本字形实际上是作为单独的四边形呈现的，每个字符一个。这些四边形往往在字形周围有大量空白空间，具体取决于其形状，并且很容易以无意中破坏其他 UI 元素批处理的方式放置文本。 文本网格重建 一个主要问题是 UI 文本网格的重建。无论何时更改 UI 文本组件，文本组件都必须重新计算用于显示实际文本的多边形。如果文本组件或其任何父游戏对象被简单地禁用和重新启用而不更改文本，也会发生这种重新计算。 对于显示大量文本标签的任何 UI，这种行为都是有问题的，最常见的是排行榜或统计屏幕。由于隐藏和显示 Unity UI 的最常见方法是启用/禁用包含该 UI 的 GameObject，因此具有大量文本组件的 UI 通常会在显示时导致不希望的帧速率中断。 有关此问题的潜在解决方法，请参阅下一步中的禁用画布部分。 动态字体和字体图集 当完整的可显示字符集非常大或在运行前未知时，动态字体是一种显示文本的便捷方式。在 Unity 的实现中，这些字体在运行时根据 UI 文本组件中遇到的字符构建一个字形图集。 加载的每个不同的 Font 对象都将保持自己的纹理图集，即使它与另一种字体在同一个字体系列中。例如，在一个控件上使用带有粗体文本的 Arial 而在另一个控件上使用 Arial Bold 将产生相同的输出，但 Unity 将保持两个不同的纹理图集 - 一个用于 Arial，一个用于 Arial Bold。 从性能的角度来看，最重要的是要理解 Unity UI 的动态字体在字体纹理图集中为每个不同的大小、样式和字符组合保留一个字形。也就是说，如果 UI 包含两个文本组件，都显示字母“A”，则： 如果两个 Text 组件共享相同的大小，则字体图集将包含一个字形。 如果两个 Text 组件的大小不同（例如，一个是 16 磅，另一个是 24 磅），那么字体图集将包含两个不同大小的字母“A”副本。 如果一个文本组件是粗体而另一个不是，则字体图集将包含一个粗体“A”和一个常规“A”。 每当具有动态字体的 UI 文本对象遇到尚未光栅化到字体纹理图集的字形时，必须重新构建字体的纹理图集。如果新字形适合当前图集，则会添加它并将图集重新上传到图形设备。但是，如果当前图集太小，则系统会尝试重建图集。它分两个阶段进行。 首先，以相同大小重建图集，仅使用活动 UI 文本组件当前显示的字形。这包括其父 Canvas 已启用但已禁用 Canvas Renderers 的 UI 文本组件。如果系统成功地将所有当前使用的字形拟合到一个新的图集中，它将对该图集进行光栅化，并且不会继续进行第二步。 其次，如果当前使用的字形集不能放入与当前图集相同大小的图集中，则通过将图集的较短尺寸加倍来创建更大的图集。例如，一个 512x512 的图集扩展为 512x1024 的图集。 由于上述算法，动态字体的图集只有在创建后才会增大。鉴于重建纹理图集的成本，必须在重建期间尽量减少。这可以通过两种方式完成。 尽可能使用非动态字体并为所需的字形集预配置支持。这通常适用于使用严格限制的字符集（例如仅拉丁/ASCII 字符）且大小范围较小的 UI。 如果必须支持非常大范围的字符，例如整个 Unicode 集，则必须将字体设置为 Dynamic。为避免可预测的性能问题，请在启动时通过Font.RequestCharactersInTexture使用一组适当的字符来填充字体的字形图集。 请注意，字体图集的重建是针对每个更改的 UI 文本组件单独触发的。当填充大量文本组件时，收集文本组件内容中的所有唯一字符并准备字体图集可能是有利的。这将确保字形图集只需要重建一次，而不是每次遇到新字形时都重建一次。 另请注意，当触发字体图集重建时，当前未包含在活动 UI 文本组件中的任何字符都不会出现在新图集中，即使它们最初是由于调用Font.RequestCharactersInTexture。要解决此限制，请订阅Font.textureRebuilt委托并查询Font.characterInfo以确保所有需要的字符都保持原样。 Font.textureRebuilt委托当前未记录。它是一个单参数 Unity Event。参数是重建纹理的字体。此活动的订阅者应遵循以下签名： public void TextureRebuiltCallback(Font rebuiltFont) { /* ... */ } 专门的字形渲染器 对于字形众所周知的情况，每个字形之间的位置相对固定，编写一个自定义组件来显示显示这些字形的精灵会更加有利。这方面的一个例子可能是分数显示。 对于乐谱，可显示的字符取自一个众所周知的字形集（数字 0-9），不会跨地区变化，并且彼此之间的距离固定。将整数分解为其数字并显示适当的数字精灵相对简单。这种专门的数字显示系统可以以一种无需分配且计算、动画和显示速度比 Canvas 驱动的 UI 文本组件快得多的方式构建。 后备字体和内存使用情况 对于必须支持大字符集的应用程序，很容易在字体导入器的“字体名称”字段中列出大量字体。如果字形不能位于主要字体中，则“字体名称”字段中列出的任何字体都将用作备用字体。回退顺序由字体在“字体名称”字段中列出的顺序决定。 但是，为了支持这种行为，Unity 会将“字体名称”字段中列出的所有字体加载到内存中。如果字体的字符集非常大，则备用字体消耗的内存量可能会变得过多。这在包含象形字体时最常见，例如日文汉字或汉字。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:3:1","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"最佳配合和性能 一般来说，UI Text 组件的Best Fit设置永远不应该被使用。 “最佳匹配”将字体大小动态调整为最大整数磅值，可以在文本组件的边界框中显示而不会溢出，并限制在可配置的最小/最大磅值。然而，由于 Unity 为每个不同大小的字符在字体图集中呈现不同的字形，因此使用最佳拟合将迅速淹没具有许多不同字形大小的图集。 从 Unity 2017.3 开始，Best Fit 使用的尺寸检测不是最优的。它为每个测试的大小增量在字体图集中生成字形，这进一步增加了生成字体图集所需的时间。它还容易导致图集溢出，从而导致旧字形被踢出图集。由于最佳拟合计算需要大量测试，这通常会驱逐其他文本组件使用的字形，并在计算出适当的字体大小后强制至少再次重建字体图集。这个特定问题已在 Unity 5.4 中得到纠正，Best Fit 不会不必要地扩展字体的纹理图集，但仍比静态大小的文本慢得多。 频繁的字体图集重建会迅速降低运行时性能并导致内存碎片。设置为 Best Fit 的文本组件的数量越多，这个问题就越严重。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:3:2","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"TextMeshPro 文本 TextMesh Pro (TMP) 是 Unity 现有文本组件（如 Text Mesh 和 UI Text）的替代品。TextMesh Pro 使用有符号距离场 (SDF) 作为其主要的文本渲染管道，从而可以在任何点大小和分辨率下清晰地渲染文本。使用一组旨在利用 SDF 文本渲染功能的自定义着色器，TextMesh Pro 可以通过简单地更改材质属性以添加视觉样式（如膨胀、轮廓、软阴影、斜角）来动态更改文本的视觉外观。纹理、发光等，并通过创建/使用材质预设来保存和调用这些视觉样式。 在 2018.1 发布之前，TextMesh Pro 作为 Asset Store 包包含在一个项目中。自 2018.1 起，TextMesh Pro 将作为包管理器包提供。 文本网格重建 很像 Unity 的内置 UIText 组件，对组件显示的文本进行更改将触发对 Canvas.SendWillRendererCanvases 和 Canvas.BuildBatch 的调用，这可能会很昂贵。尽量减少对 TextMeshProUGUI 组件的文本字段的更改，并确保将文本经常更改的父级 TextMeshProUGUI 组件更改为具有自己的 Canvas 组件的父级 GameObject，以确保 Canvas 重建调用保持尽可能高效。 请注意，对于在世界空间中显示的文本，我们建议用户使用普通的 TextMeshPro 组件而不是使用 TextMeshProUGUI，因为在 Worldspace 中使用 Canvases 可能会降低效率。直接使用 TextMeshPro 会更有效，因为它不会产生画布系统开销。 字体和内存使用 鉴于 TMP 中没有动态字体功能，因此必须依赖备用字体。了解如何加载和使用备用字体对于在使用 TMP 时优化内存至关重要。 TMP 中的字形发现是递归完成的——也就是说，当 TMP 字体资源中缺少一个字形时，TMP 会从列表中的第一个回退开始以及它们自己的回退开始迭代当前分配或活动的回退字体资源列表。如果仍未找到字形，TMP 将搜索可能分配给文本对象的任何 Sprite 资源以及分配给此 Sprite 资源的任何回退。如果仍然没有找到所需的字形，TMP 将递归搜索在 TMP 设置文件中分配的一般后备列表，然后是默认 Sprite 资源。如果仍然无法找到此字形，它将搜索在 TMP 设置中分配的默认字体资源。作为最后的手段，TMP 将使用并显示在 TMP 设置文件中定义的缺失字形替换字符。 TextMesh Pro 的字体资源在场景或项目中被引用时被加载。它们主要由 TextMeshPro 文本组件、TMP 设置以及字体资源本身作为后备字体引用。如果在 TMP 设置资源中引用了字体资源，则当第一个带有 TMP 文本组件的场景被激活时，这些字体资源及其所有备用字体资源将被递归加载。如果引用了默认的 sprite sheet 资源，那么它也将被加载。 此外，当给定场景中的 TextMeshPro 组件引用字体资源并且尚未通过 TMP 设置加载时，一旦激活组件，将递归加载所引用的字体资源及其所有后备字体资源。在处理具有多种字体的项目时，请务必牢记此过程，尤其是在可用内存存在问题的情况下。 由于上述原因，在使用 TMP 时本地化项目成为一个问题，因为预先通过 TMP 设置加载所有本地化语言字体资源将对内存压力造成不利影响。如果本地化是必要的要求，我们建议仅在必要时（加载各种场景时）分配这些字体资源或备用或使用资源包以模块化方式加载字体资源的潜在策略。 当应用程序启动时，应该包含一个引导步骤来验证用户的语言环境并为每个字体资产设置字体资产后备： 为基本 TMP 字体资源创建资源包（例如，每种字体的最小拉丁字形） 为每种语言所需的备用 TMP 字体资产创建一个资产包（例如，为日语所需的每种字体创建一个 TMP 字体资产的资产包） 在引导步骤中加载您的基础资产包 根据语言环境，使用备用字体加载所需的 Asset Bundle 对于基础资源包中的每种字体，从本地化字体资源包中分配备用字体资源 继续引导您的游戏 如果不使用图像，也可以从 TMP 设置中删除默认 Sprite 资源引用，以节省额外的适度内存。 最佳配合和性能 再一次，鉴于 TextMesh Pro 没有动态字体功能，不会出现上述 UGUI UIText 部分中关于最佳拟合的问题。在 TextMesh Pro 组件上使用 Best Fit 时唯一需要考虑的是使用二分搜索来找到正确的大小。使用文本自动调整大小时，最好测试最长/最大文本块的最佳点大小。一旦确定了此最佳大小，请禁用给定文本对象的自动调整大小，然后在其他文本对象上手动设置此最佳点大小。这有利于提高性能并避免一组文本对象使用不同的点大小，这被认为是不良的视觉/印刷实践。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:3:3","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"滚动视图 在填充率问题之后，Unity UI 的滚动视图是运行时性能问题的第二大常见来源。滚动视图通常需要大量的 UI 元素来表示它们的内容。填充滚动视图有两种基本方法： 用代表所有滚动视图内容所需的所有元素填充它 汇集元素，根据需要重新定位它们以表示可见内容。 这两种解决方案都有问题。 随着要表示的项目数量的增加，第一个解决方案需要越来越多的时间来实例化所有 UI 元素，并且还增加了重建 Scroll View 所需的时间。如果在 Scroll View 中只需要少量元素，例如在 Scroll View 中只需要显示少量 Text 组件，那么这种方法因其简单性而受到青睐。 第二种解决方案需要大量代码才能在当前 UI 和布局系统下正确实现。下面将更详细地讨论两种可能的方法。对于任何非常复杂的滚动 UI，通常需要某种池化方法来避免性能问题。 尽管存在这些问题，但所有方法都可以通过将 RectMask2D 组件添加到 Scroll View 来改进。此组件确保在 Scroll View 视口之外的 Scroll View 元素不包含在可绘制元素列表中，这些元素必须在重建 Canvas 时生成、排序和分析其几何图形。 简单的滚动视图元素池 使用 Scroll View 实现对象池的最简单方法，同时保留使用 Unity 内置 Scroll View 组件的原生便利性，采用混合方法： 要在 UI 中布局元素，这将允许布局系统正确计算 Scroll View 内容的大小并允许滚动条正常工作，请使用带有Layout Element组件的 GameObjects 作为可见 UI 元素的“占位符”。 然后，实例化一个足以填充 Scroll View 可见区域的可见部分的可见 UI 元素池，并将这些元素作为定位占位符的父级。当 Scroll View 滚动时，重用 UI 元素来显示滚动到视图中的内容。 这将大大减少必须批处理的 UI 元素的数量，因为批处理的成本只会根据 Canvas 内的 Canvas Renderer 的数量而不是 Rect Transforms 的数量而增加。 简单方法的问题 目前，每当任何 UI 元素重新设置父级或更改其同级顺序时，该元素及其所有子元素都会被标记为“脏”并强制重建其 Canvas。 这样做的原因是 Unity 没有分离用于重新调整变换和更改其兄弟顺序的回调。这两个事件都会触发OnTransformParentChanged回调。在 Unity UI 的Graphic类的源代码中（参见源代码中的 Graphic.cs），该回调被实现并调用方法SetAllDirty。通过弄脏 Graphic，系统可以确保 Graphic 在下一帧渲染之前重建其布局和顶点。 可以将画布分配给 Scroll View 中每个元素的根 RectTransform，然后将重建限制为仅重新设置父元素而不是 Scroll View 的全部内容。但是，这往往会增加渲染 Scroll View 所需的绘制调用次数。此外，如果 Scroll View 中的单个元素很复杂并且由十几个 Graphic 组件组成，特别是如果每​​个元素上有大量 Layout 组件，那么重建它们的成本通常高到足以显着降低低端设备的帧速率。 如果 Scroll View UI 元素没有可变大小，则无需重新计算布局和顶点。但是，避免这种行为需要实现基于位置更改而不是父级或同级顺序更改的对象池解决方案。 基于位置的滚动视图池 为了避免上述问题，可以通过简单地移动其包含的 UI 元素的 RectTransforms 来创建一个 Scroll View 池其对象。这避免了在未更改尺寸的情况下重新构建移动的 RectTransform 内容的需要，从而显着提高了 Scroll View 的性能。 要做到这一点，通常最好编写一个自定义的 Scroll View 子类或编写一个自定义的 Layout Group 组件。后者通常是更简单的解决方案，可以通过实现 Unity UI 的LayoutGroup抽象基类的子类来完成。 自定义 Layout Group 可以分析底层源数据以检查必须显示多少数据元素，并且可以适当地调整 Scroll View 的 Content RectTransform 的大小。然后它可以订阅Scroll View 更改事件并使用这些事件相应地重新定位其可见元素。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:3:4","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"其他 UI 优化技巧和技巧 有时没有干净的方法来优化 UI。本节包含一些可能有助于提高 UI 性能的建议，但有些建议在结构上“不干净”，可能难以维护，或者可能有丑陋的副作用。其他可能是 UI 中行为的变通方法，旨在简化初始开发，但也可以相对简单地创建性能问题。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:4:0","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"基于 RectTransform 的布局 布局组件相对昂贵，因为它们必须在每次标记为脏时重新计算其子元素的大小和位置。（有关详细信息，请参阅基础步骤的图形重建部分。）如果给定 Layout 中的元素数量相对较少且固定，并且 Layout 具有相对简单的结构，则可以将 Layout 替换为 RectTransform - 基于布局。 通过分配 RectTransform 的锚点，可以使 RectTransform 的位置和大小根据其父级进行缩放。例如，一个简单的两列布局可以用两个 RectTransforms 来实现： 左列的锚点应该是 X: (0, 0.5) 和 Y: (0, 1) 右列的锚点应该是 X: (0.5, 1) 和 Y: (0, 1) RectTransform 的大小和位置的计算将由 Transform 系统本身以本机代码驱动。这通常比依赖 Layout 系统更高效。也可以编写设置基于 RectTransform 的布局的 MonoBehaviours。但是，这是一项相对复杂的任务，超出了本指南的范围。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:4:1","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"禁用画布 当显示或隐藏 UI 的离散部分时，通常在 UI 的根部启用或禁用游戏对象。这可确保禁用 UI 中的任何组件都不会接收输入或 Unity 回调。 但是，这也会导致 Canvas 丢弃其 VBO 数据。重新启用画布将需要画布（和任何子画布）运行重建和重新批处理过程。如果这种情况频繁发生，增加的 CPU 使用率可能会导致应用程序的帧速率卡顿。 一种可能但很麻烦的解决方法是将要显示/隐藏的 UI 放置在其自己的 Canvas 或 Sub-canvas 上，然后仅启用/禁用此对象上的 Canvas 组件。 这将导致 UI 的网格不被绘制，但它们将保留在内存中，并且它们的原始批处理将被保留。此外，不会在 UI 的层次结构中调用OnEnable或OnDisable回调。 但是请注意，这不会禁用隐藏 UI 中的任何 MonoBehaviours，因此这些 MonoBehaviours 仍将接收 Unity 生命周期回调，例如 Update。 为避免此问题，将以这种方式禁用的 UI 上的 MonoBehaviour 不应直接实现 Unity 的生命周期回调，而应从 UI 根 GameObject 上的“回调管理器”MonoBehaviour 接收其回调。每当显示/隐藏 UI 时都可以通知这个“回调管理器”，并且可以确保根据需要传播或不传播生命周期事件。对此“回调管理器”模式的进一步解释超出了本指南的范围。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:4:2","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"分配事件摄像机 如果使用 Unity 的内置输入管理器以及设置为在World Space或Screen Space – Camera模式中渲染的画布，请务必分别设置 Event Camera 或 Render Camera 属性。从脚本中，这始终作为worldCamera属性公开。 如果未设置此属性，则 Unity UI 将通过查找附加到带有 Main Camera 标签的 GameObjects 的 Camera 组件来搜索主摄像头。每个世界空间或相机空间画布至少会发生一次此查找。由于已知GameObject.FindWithTag很慢，因此强烈建议所有世界空间和相机空间画布在设计时或初始化时分配其相机属性。 覆盖画布不会出现此问题。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:4:3","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"UI源代码定制 UI 系统旨在支持大量用例。这种灵活性很好，但这也意味着在不破坏其他功能的情况下无法轻松完成某些优化。如果您最终遇到通过更改 C# UI 源代码可以获得一些 CPU 周期的情况，则可以重新编译 UI DLL 并覆盖 Unity 附带的那个。此过程记录在Bitbucket 存储库的自述文件中。确保获取与您的 Unity 版本对应的源代码。 但这只能作为最后的手段，因为有一些重要的缺点。首先，您必须找到一种方法将这个新的 DLL 分发给您的开发人员和构建机器。然后，每次升级 Unity 时，都必须将更改与新的 UI 源代码合并。在朝着这个方向前进之前，请确保您不能只是扩展现有类或编写自己的组件版本。 ","date":"2022-10-13","objectID":"/posts/untiy3d_unityui/:4:4","tags":["ugui","unity"],"title":"Unity UI优化原理","uri":"/posts/untiy3d_unityui/"},{"categories":["unity"],"content":"Unity中的四元数的使用","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"四元数的概念 四元数，这是一个图形学的概念，一般没怎么见过，图形学中比较常见的角位移的表示方法有“矩阵”、“欧拉角”、“四元数”这三种。可以说各有各的优点和不足，不同的场合用不同的方法。其中四元数的优点有：平滑插值、快速连接、角位移求逆、可以与矩阵形式快速转换、仅用四个数表示。不过，它也有一些缺点：比欧拉角多一个数表示、可能不合法（如：坏的输入数据或者浮点数累计都可能使四元数不合法，不过可以通过四元数标准化来解决这个问题）、晦涩难懂。 那为啥四元数是四个数呢？其实还是有个小故事的。话说当时十九世纪的时候，爱尔兰的数学家Hamilton一直在研究如何将复数从2D扩展至3D，他一直以为扩展至3D应该有两个虚部（可是他错了，哈哈）。有一天他在路上突发奇想，我们搞搞三个虚部的试试！结果他就成功了，于是乎他就把答案刻在了Broome桥上。说到这里，也就明白了，四元数其实就是定义了一个有三个虚部的复数w+xi+yj+zk。记法[w,(x,y,z)]。 好了，上面我们就基本清楚四元数的作用以及好处与坑了，下面开始正式讲讲Unity中我们如何使用一些常见的四元数操作。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:1:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"Unity中的四元数 基本的旋转，我们可以通过Transform.Rotate来实现，但是当我们希望对旋转角度进行一些计算的时候，就要用到四元数Quaternion了。Quaternion的变量比较少也没什么可说的，大家一看都明白。唯一要说的就是xyzw的取值范围是[-1,1],物体并不是旋转一周就所有数值回归初始值，而是两周。 初始值： (0,0,0,1) 沿着y轴旋转：180°(0,1,0,0) 360°（0,0,0,-1）540°(0,-1,0,0) 720°(0,0,0,1) 沿着x轴旋转：180°(-1,0,0,0) 360°（0,0,0,-1）540°(1,0,0,0) 720°(0,0,0,1) 无旋转的写法是Quaternion.identify。 在unity3d中, quaternion 的乘法操作 (operator * ) 有两种操作: 乘法操作 (1) quaternion * quaternion , 例如 q = t * p; 这是将一个点先进行t 操作旋转,然后进行p操作旋转. (2) Quaternion * Vector3, 例如 p : Vector3, t : Quaternion , q : Quaternion; q = t * p; 这是将点p 进性t 操作旋转; 我进行的是第2种操作,即对一个向量进行旋转; 首先 ,Quaternion 的基本数学方程为 : Q = cos (a/2) + i (x * sin(a/2)) + j (y * sin(a/2)) + k(z * sin(a/2)) (a 为旋转角度) Q.w = cos (angle / 2) Q.x = axis.x * sin (angle / 2) Q.y = axis.y * sin (angle / 2) Q.z = axis.z * sin (angle / 2) 我们只要有角度就可以给出四元数的四个部分值,例如我想要让点M=Vector3(o,p,q) 绕x轴顺时针旋转90度;那么对应的quaternion数值就应该为: Q : Quaternion; Q.x = 1 * sin(90度/2) = sin(45度) = 0.7071 Q.y = 0; Q.z = 0; Q.w = cos(90度/2) = cos (45度) = 0.7071 Q = (0.7071, 0 , 0 , 0.7071); m = Q * m; （将点m 绕 x轴(1,0,0) 顺时针旋转了90度) ** 下面我就按照Unity的API介绍下四元数相关的几个基本函数。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:2:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"一、LookRotation 声明形式：public static Quaternion LookRotation ( Vector3 forward, Vector3 upwards=Vector3.up ) 这个功能很实用，传入的两个参数分别代表前方盯着的方向以及自己的上方向。它可以让一个GameObject转动脑袋盯着另一个物体。如： public Transform target; void Update() { Vector3 relativePos = target.position - transform.position; Quaternion rotation = Quaternion.LookRotation(relativePos); transform.rotation = rotation; } 这段代码就可以让当前的object时时盯着target不放，当然，你也可以自定义up朝向，这里默认是Vector3.up。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:3:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"二、Angle 声明形式：public static float Angle ( Quaternion a, Quaternion b ) 这个就比较简单了，它可以计算两个旋转之间的夹角。与Vector3.Angle()作用是一样的。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:4:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"三、Euler 声明形式：public static Quaternion Euler ( float x, float y, float z ) 或者： public static Quaternion Euler ( Vector3 euler ) 这个函数可以将一个欧拉形式的旋转转换成四元数形式的旋转。传入的参数分别是欧拉轴上的转动角度。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:5:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"四、Slerp 声明形式：public static Quaternion Slerp ( Quaternion from, Quaternion to, float t ) 基本意思就是线性地从一个角度旋转到另一个角度，其中，旋转匀速增加t。 附加内容：很多时候from 和to都不是固定的，而且上一个脚本也不能保证所有角度下的旋转速度一致。所以我写了这个脚本来保证可以应付大多数情况。 Transform target; float rotateSpeed = 30.0f; Quaternion wantedRotation = Quaternion.FromToRotation(transform.position, target.position); float t = rotateSpeed/Quaternion.Angle(transform.rotation, wantedRotation)*Time.deltaTime; transform.rotation = Quaternion.Slerp(transform.rotation, target.rotation, t); 这个脚本可以保证物体的旋转速度永远是rotateSpeed。如果自身坐标和目标之间的夹角是X度，我们想以s=30度每秒的速度旋转到目标的方向,则每秒旋转的角度的比例为s/X。 再乘以每次旋转的时间Time.deltaTime我们就得到了用来匀速旋转的t。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:6:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"五、FromToRotation 声明形式：public static Quaternion FromToRotation ( Vector3 from, Vector3 to ) 它是得到从一个方向到另一个方向的旋转。就是转一个方向，就这么简单。 ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:7:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["unity"],"content":"六、identity 这个不是一个函数，它是一个只读的变量。它代表世界坐标系或者父物体坐标系中的无旋转方位。 Written with StackEdit. ","date":"2022-10-12","objectID":"/posts/unity3d_quaternion/:8:0","tags":["Markdown","unity"],"title":"Unity3D中的Quaternion（四元数）","uri":"/posts/unity3d_quaternion/"},{"categories":["buildwebsite"],"content":" liunx系统内存命令","date":"2022-10-12","objectID":"/posts/website_liunxmemory/","tags":["liunx服务器"],"title":"如何查看linux服务器内存使用情况","uri":"/posts/website_liunxmemory/"},{"categories":["buildwebsite"],"content":"参考文章 如何查看linux服务器内存使用情况 ","date":"2022-10-12","objectID":"/posts/website_liunxmemory/:0:0","tags":["liunx服务器"],"title":"如何查看linux服务器内存使用情况","uri":"/posts/website_liunxmemory/"},{"categories":["buildwebsite"],"content":"1. free命令 free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 free命令默认是显示单位kb，可以采用free -m和free -g命令查看，分别表示MB和GB 另外，free -h会自动选择以适合理解的容量单位显示 Mem:表示物理内存统计，如果机器剩余内存非常小，一般小于总内存的20%，则判断为系统物理内存不够 Swap: 表示硬盘上交换分区的使用情况，如剩余空间较小，需要留意当前系统内存使用情况及负载，当Swap的used值大于0时，则表示操作系统物理内存不够，已经开始使用硬盘内存了。 ps -eo pmem,pcpu,rss,vsize,args | sort -k 1 -r | less 执行以上命令可查看各个程序进程内存使用的内存情况，如下图所示，第一列为进程占用的内存百分比，可以看到哪些应用程序占的内存比较多，用于排查问题： ","date":"2022-10-12","objectID":"/posts/website_liunxmemory/:0:1","tags":["liunx服务器"],"title":"如何查看linux服务器内存使用情况","uri":"/posts/website_liunxmemory/"},{"categories":["buildwebsite"],"content":"2.top命令 top 命令查看系统的实时负载， 包括进程、CPU负载、内存使用等等； 直接输入top命令 top 命令查看系统的实时负载， 包括进程、CPU负载、内存使用等等； 　进入top的实时界面后，默认按照CPU的使用率排序，通过“shift+m”按键将进程按照内存使用情况排序，可以查看哪些进程是当前系统中的内存开销“大户”。 　top命令中，按下 f 键，进入选择排序列的界面，这里可以选择要显示的信息列，要按照哪些信息列进行排序等，该界面上有简要的介绍，这里不再赘述。 ","date":"2022-10-12","objectID":"/posts/website_liunxmemory/:0:2","tags":["liunx服务器"],"title":"如何查看linux服务器内存使用情况","uri":"/posts/website_liunxmemory/"},{"categories":["buildwebsite"],"content":" mysql内存占用高","date":"2022-10-12","objectID":"/posts/website_mysql_memory/","tags":["mysql"],"title":"mysql内存占用高","uri":"/posts/website_mysql_memory/"},{"categories":["buildwebsite"],"content":"修改 MySQL 配置文件 my.cnf，找到 [mysqld] 下添加如下内容： [mysqld] // 此处省略其他配置，添加如下内容 table_open_cache=200 table_definition_cache=400 performance_schema_max_table_instances=400 performance_schema=off 保存然后重启 MySQL，OK！内存已经降到 10%+ 了。 重启mysql命令: systemctl restart mysqld 各个配置项的具体用途： table_open_cache: 高速缓存的大小，每当访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，下次查询该表时首先从高速缓存区查询，如果表在缓存中则直接从缓存查询，从而大幅提高查询速度。 table_definition_cache: 定义了内存中可打开的表结构数量。 performance_schema_max_table_instances: 检测的表对象的最大数目。 performance_schema: 主要用来收集 MySQL 性能参数，启用 performance_schema 之后，server 会持续不间断地监测。【罪魁祸首】 通过调整前面 3 个配置项的值，占用内存均有 1~3% 程度的降低，罪魁祸首便是 performance_schema，将其设置为 off 之后，内存直接降低了 20%！ 其详细介绍可参考 MySQL 官方文档：MySQL Performance Schema 当然除了上面几个配置项之外，MySQL 仍有许多可以优化的配置项，但是现在既然已经实现了自己的目的，就暂时不进行扩展阅读了 ","date":"2022-10-12","objectID":"/posts/website_mysql_memory/:0:0","tags":["mysql"],"title":"mysql内存占用高","uri":"/posts/website_mysql_memory/"},{"categories":["buildwebsite"],"content":" 在初次搭建wordpress成功后,安装wordpress插件时缺发现需要ftp服务","date":"2022-10-12","objectID":"/posts/website_wordpress_ftp/","tags":["ftp","Wordpress"],"title":"WordPress中安装插件需要ftp怎么办？","uri":"/posts/website_wordpress_ftp/"},{"categories":["buildwebsite"],"content":"在初次搭建wordpress成功后,老想安装wordpress中有趣的插件时缺发现需要ftp服务，同样的升级插件的话也需要输入ftp的用户名密码。其实不用真的搭建一个ftp服务器,那么,怎么绕过这道程序呢.其实很简单,我们只需在wordpress根目录找到wp-config.php,添加以下代码: define(\"FS_METHOD\",\"direct\"); define(\"FS_CHMOD_DIR\", 0777); define(\"FS_CHMOD_FILE\", 0777); 这时又会提醒无法安装,理由是文件无法创建目录,这个好解决.给wordpress添加权限就好 chmod -R 777 wordpress的目录. ","date":"2022-10-12","objectID":"/posts/website_wordpress_ftp/:0:0","tags":["ftp","Wordpress"],"title":"WordPress中安装插件需要ftp怎么办？","uri":"/posts/website_wordpress_ftp/"},{"categories":["buildwebsite"],"content":" 安装dnf及常见的 dnf 命令介绍","date":"2022-10-12","objectID":"/posts/website_dnf/","tags":["dnf"],"title":"安装dnf","uri":"/posts/website_dnf/"},{"categories":["buildwebsite"],"content":"安装 dnf DNF 并未默认安装在 RHEL 或 CentOS 7系统中 为了安装 dnf ，必须先安装并启用 epel-release 依赖 yum install epel-release 使用 epel-release 依赖中的 YUM 命令来安装 dnf 包 yum install dnf 常见的 dnf 命令介绍 查看 dnf 版本 dnf --version 查看系统中可用的 dnf 软件库 dnf repolist 查看系统中可用和不可用的软件库 dnf repolist all 列出所有RPM包 dnf list 列出已经安装的RPM包 dnf list installed 列出可供安装的RPM包 dnf list available 搜索某包 (以搜索nginx为例) dnf search nginx 查看某包的详情 dnf info nginx 安装包 dnf install nginx 升级包 dnf update nginx 检查系统软件包更新 dnf check-update 升级系统中所有软件包 dnf update OR dnf upgrade 删除包 dnf remove nginx OR dnf erase nginx 删除无用孤立的软件包 dnf autoremove 删除缓存的无用软件包 dnf clean all 获取有关某条命令的使用帮助 dnf help clean 重新安装特定软件包 dnf reinstall nginx 回滚某个特定软件的版本 dnf downgrade nginx ","date":"2022-10-12","objectID":"/posts/website_dnf/:0:0","tags":["dnf"],"title":"安装dnf","uri":"/posts/website_dnf/"},{"categories":["buildwebsite"],"content":" php内存占用过高","date":"2022-10-12","objectID":"/posts/website_php_memory/","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"参考文章 php-fpm.conf就是php-fpm的配置文件，路径一般在/etc下 不清楚的可以通过命令行找到 查看php-fpm位置: ps -ef | grep 'php-fpm' 由于方便管理把php-fpm配置文件拆开了。在/etc/php-fpm.d的的www.conf内 配置重要的参数说明如下： pm = dynamic #指定进程管理方式，有3种可供选择：static、dynamic和ondemand。 pm.max_children = 16 #static模式下创建的子进程数或dynamic模式下同一时刻允许最大的php-fpm子进程数量。 pm.start_servers = 10 #动态方式下的起始php-fpm进程数量。 pm.min_spare_servers = 8 #动态方式下服务器空闲时最小php-fpm进程数量。 pm.max_spare_servers = 16 #动态方式下服务器空闲时最大php-fpm进程数量。 pm.max_requests = 2000 #php-fpm子进程能处理的最大请求数。 pm.process_idle_timeout = 10s request_terminate_timeout = 120 pm三种进程管理模式说明如下： pm = static，始终保持一个固定数量的子进程，这个数由pm.max_children定义，这种方式很不灵活，也通常不是默认的。 pm = dynamic，启动时会产生固定数量的子进程（由pm.start_servers控制）可以理解成最小子进程数，而最大子进程数则由pm.max_children去控制，子进程数会在最大和最小数范围中变化。闲置的子进程数还可以由另2个配置控制，分别是pm.min_spare_servers和pm.max_spare_servers。如果闲置的子进程超出了pm.max_spare_servers，则会被杀掉。小于pm.min_spare_servers则会启动进程（注意，pm.max_spare_servers应小于pm.max_children）。 pm = ondemand，这种模式和pm = dynamic相反，把内存放在第一位，每个闲置进程在持续闲置了pm.process_idle_timeout秒后就会被杀掉，如果服务器长时间没有请求，就只会有一个php-fpm主进程。弊端是遇到高峰期或者如果pm.process_idle_timeout的值太短的话，容易出现504 Gateway Time-out错误，因此pm = dynamic和pm = ondemand谁更适合视实际情况而定。 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:0:0","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"解决php-fpm进程占用内存大问题 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:1:0","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"3.1 调整管理模式 static管理模式适合比较大内存的服务器，而dynamic则适合小内存的服务器，你可以设置一个pm.min_spare_servers和pm.max_spare_servers合理范围，这样进程数会不断变动。ondemand模式则更加适合微小内存，例如512MB或者256MB内存，以及对可用性要求不高的环境。 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:1:1","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"减少php-fpm进程数 如果你的VPS主机的内存被占用耗尽，可以检查一下你的php-fpm进程数，按照php-fpm进程数=内存/2/30来计算，1GB内存适合的php-fpm进程数为10-20之间，具体还得根据你的PHP加载的附加组件有关系。 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:1:2","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"php-fpm配置示例 这里以1GB内存的VPS配置php-fpm为演示，实际操作来看设置数值还得根据服务器本身的性能、PHP等综合考虑。 pm = dynamic #dynamic和ondemand适合小内存。 pm.max_children = 15 #static模式下生效，dynamic不生效。 pm.start_servers = 8 #dynamic模式下开机的进程数量。 pm.min_spare_servers = 6 #dynamic模式下最小php-fpm进程数量。 pm.max_spare_servers = 15 #dynamic模式下最大php-fpm进程数量。 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:1:3","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":"解决php-fpm进程不释放内存问题 上面通过减少php-fpm进程总数来达到减少php-fpm内存占用的问题，实际使用过程中发现php-fpm进程还存长期占用内存而不释放的问题。解决的方法就是减少pm.max_requests数。 最大请求数max_requests，即当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，自动重启该进程，这样达到了释放内存的目的了。以1GB内存的VPS主机设置为例（如果你设置的数值没有达到释放内存可以继续调低）： pm.max_requests = 500 当php-fpm进程达到了pm.max_requests设定的数值后，就会重启该进程，从而释放内存。 ","date":"2022-10-12","objectID":"/posts/website_php_memory/:2:0","tags":["php"],"title":"php内存占用过高","uri":"/posts/website_php_memory/"},{"categories":["buildwebsite"],"content":" php命令行操作","date":"2022-10-12","objectID":"/posts/website_php_order/","tags":["php"],"title":"php命令行操作","uri":"/posts/website_php_order/"},{"categories":["buildwebsite"],"content":"查看php-fpm状态 systemctl status php-fpm 启动php-fpm systemctl start php-fpm 停止php-fpm systemctl stop php-fpm 重启php-fpm systemctl restart php-fpm 查看php-fpm位置 ps -ef | grep 'php-fpm' ","date":"2022-10-12","objectID":"/posts/website_php_order/:0:0","tags":["php"],"title":"php命令行操作","uri":"/posts/website_php_order/"},{"categories":["buildwebsite"],"content":" 使用nginx的代理转发功能帮我们实现共用80端口的需求","date":"2022-10-12","objectID":"/posts/website_nginx_moreport/","tags":["nginx"],"title":"nginx配置多个域名使用同一个端口","uri":"/posts/website_nginx_moreport/"},{"categories":["buildwebsite"],"content":"方法1 随着服务器性能的提升和业务的需求，一台服务器上往往会同时有多个服务，这些服务都希望监听80端口，比如有a.com和b.com。这时候我们可以使用nginx的代理转发功能帮我们实现共用80端口的需求。 先在两个空闲的端口上分别部署项目（非80，假设是8080和8081）nginx配置如下： # a项目配置nginx server { listen 8080; root /usr/share/nginx/html; #这里是默认路径，生产中代码存放路径：root /web/vue-base-demo/dist/; index index.html; location / {} } # b项目配置nginx server { listen 8081; root /usr/share/nginx/html; #这里是默认路径，生产中代码存放路径：root /web/react-base-demo/build; index index.html; location / {} } 紧接着如果已经做好域名解析，希望a.com打开a项目，b.com打开b项目。我们需要再做两个代理，如下: # nginx 80端口配置 （监听a二级域名） server { listen 80; server_name a.com; location / { proxy_pass http://localhost:8080; # 转发 } } # nginx 80端口配置 （监听b二级域名） server { listen 80; server_name b.com; location / { proxy_pass http://localhost:8081; # 转发 } } nginx如果检测到a.com的请求，将原样转发请求到本机的8080端口，如果检测到的是b.com请求，也会将请求转发到8081端口。 测试：浏览器输入http://a.com或http://b.com即可。 ","date":"2022-10-12","objectID":"/posts/website_nginx_moreport/:1:0","tags":["nginx"],"title":"nginx配置多个域名使用同一个端口","uri":"/posts/website_nginx_moreport/"},{"categories":["buildwebsite"],"content":"方法2 server { listen 80; server_name www.server110.com; #绑定域名 index index.htm index.html index.php; #默认文件 root /home/www/server110.com; #网站根目录 include location.conf; #调用其他规则，也可去除 } server { listen 80; server_name msn.server110.com; #绑定域名 index index.htm index.html index.php; #默认文件 root /home/www/msn.server110.com; #网站根目录 include location.conf; #调用其他规则，也可去除 } 不带www的域名加301跳转 若不带 www 的域名需加 301 跳转，则先绑定不带 www 的域名，且无需写网站目录，直接进行 301 跳转，如： server { listen 80; server_name server110.com; rewrite ^/(.*) http://www.server110.com/$1 permanent; } 添加404网页 添加 404 网页，可以直接在配置中添加，如： server { listen 80; server_name www.server110.com; #绑定域名 index index.htm index.html index.php; #默认文件 root /home/www/server110.com; #网站根目录 include location.conf; #调用其他规则，也可去除 error_page 404 /404.html; } ","date":"2022-10-12","objectID":"/posts/website_nginx_moreport/:2:0","tags":["nginx"],"title":"nginx配置多个域名使用同一个端口","uri":"/posts/website_nginx_moreport/"},{"categories":["buildwebsite"],"content":" nginx命令行操作","date":"2022-10-12","objectID":"/posts/website_nginx_order/","tags":["nginx"],"title":"nginx命令行操作","uri":"/posts/website_nginx_order/"},{"categories":["buildwebsite"],"content":"查看nginx服务器的状态 sudo systemctl status nginx 开启nginx sudo systemctl start nginx 停止nginx sudo systemctl stop nginx 重启nginx sudo systemctl restart nginx 上面命令行无法关闭nginx时候使用 关闭： sudo killall nginx 开启： sudo nginx或者sudo service nginx start 设置开机自启动 systemctl enable nginx ","date":"2022-10-12","objectID":"/posts/website_nginx_order/:0:0","tags":["nginx"],"title":"nginx命令行操作","uri":"/posts/website_nginx_order/"},{"categories":["buildwebsite"],"content":"手动安装LNMP与wordpress","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"参考文章 参考文章2 ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:0:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤1：安装Nginx 因为本人早先已经装过nginx，所以采用的手动安装LNMP。 运行以下命令安装Nginx。 本教程将选用Nginx 1.16.1版本。 说明 您可以访问Nginx官方安装包获取适用于CentOS 8系统的多版本的Nginx安装包。 dnf -y install http://nginx.org/packages/centos/8/x86_64/RPMS/nginx-1.16.1-1.el8.ngx.x86_64.rpm 运行以下命令查看Nginx版本。 nginx -v 查看版本结果如下所示。 nginx version:nginx/1.16.1 ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:1:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤2：安装MySQL 运行以下命令安装MySQL。 dnf -y install @mysql 运行以下命令查看MySQL版本。 mysql -V 查看版本结果如下所示。 mysql Ver 8.0.17 for Linux on x86_64 (Source distribution) ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:2:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤3：安装PHP 运行以下命令添加并更新epel源。 dnf-yinstallepel-releasednfupdateepel-release 运行以下命令删除缓存的无用软件包并更新软件源。 dnf clean all dnf makecache 启用php:7.3模块。 说明 本示例使用php:7.3版本。如果您需要使用PHP 7.4版本，需要先安装remi源。remi源安装命令为dnf -y install https://rpms.remirepo.net/enterprise/remi-release-8.rpm。 dnf module enable php:7.3 运行以下命令安装PHP相应的模块。 dnf install php php-curl php-dom php-exif php-fileinfo php-fpm php-gd php-hash php-json php-mbstring php-mysqli php-openssl php-pcre php-xml libsodium 运行以下命令查看PHP版本。 php -v 查看版本结果如下所示。 PHP 7.3.5 (cli) (built:Apr 30 2019 08:37:17) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.5, Copyright (c) 1998-2018 Zend Technologies ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:3:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤4：配置Nginx 本人配置都配在/etc/nginx/nginx.conf内，直接修改当前配置的内容 运行以下命令打开默认配置文件。 vi /etc/nginx/nginx.conf 按i进入编辑模式。 在location大括号内，修改以下内容。 location / { #将该路径替换为您的网站根目录。 root /usr/share/nginx/html1/wordpress; #添加默认首页信息index.php。 index index.html index.htm index.php; } 去掉被注释的location ~ \\.php$大括号内容前的#，并修改大括号的内容。 修改完成如下所示。 location ~ \\.php$ { #将该路径替换为您的网站根目录。 root /usr/share/nginx/html1/wordpress; #Nginx通过unix套接字与PHP-FPM建立联系，该配置与/etc/php-fpm.d/www.conf文件内的listen配置一致。 fastcgi_pass unix:/run/php-fpm/www.sock; fastcgi_index index.php; #将/scripts$fastcgi_script_name修改为$document_root$fastcgi_script_name。 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #Nginx调用fastcgi接口处理PHP请求。 include fastcgi_params; } 说明** Nginx与PHP-FPM进程间通信方式有两种。 TCP Socket：该方式能够通过网络，可用于跨服务器通信的场景。 UNIX Domain Socket：该方式不能通过网络，只能用于同一服务器中通信的场景。 按下Esc键，并输入:wq保存退出文件。 运行以下命令启动Nginx服务。 systemctlstartnginx 运行以下命令设置Nginx服务开机自启动。 systemctl enable nginx ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:4:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤5：配置MySQL 运行以下命令启动MySQL，并设置为开机自启动。 systemctlenable--now mysqld 运行以下命令查看MySQL是否已启动。 systemctl status mysqld 查看返回结果中Active: active (running)表示已启动。 运行以下命令执行MySQL安全性操作并设置密码。 mysql_secure_installation 命令运行后，根据命令行提示执行如下操作。 输入Y并回车开始相关配置。 选择密码验证策略强度，输入2并回车。 策略0表示低，1表示中，2表示高。建议您选择高强度的密码验证策略。 设置MySQL的新密码并确认。 本示例设置密码PASSword123！。 输入Y并回车继续使用提供的密码。 输入Y并回车移除匿名用户。 设置是否允许远程连接MySQL。 不需要远程连接时，输入Y并回车。 需要远程连接时，输入N或其他任意非Y的按键，并回车。 输入Y并回车删除test库以及对test库的访问权限。 输入Y并回车重新加载授权表。 ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:5:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤6：配置PHP 修改PHP配置文件。 运行以下命令打开配置文件。 vi /etc/php-fpm.d/www.conf 按i进入编辑模式。 找到user = apache和group = apache，将apache修改为nginx。 按下Esc键，并输入:wq保存退出文件。 运行以下命令启动PHP-FPM。 systemctlstartphp-fpm 运行以下命令设置PHP-FPM开机自启动。 systemctl enable php-fpm ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:6:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["buildwebsite"],"content":"步骤7：搭建WordPress网站 远程连接部署好LNMP环境的服务器，配置WordPress数据库。 远程连接服务器 进入MySQL数据库。 使用root用户登录MySQL，并输入密码。密码为您在搭建环境时为数据库设置的密码。 mysql -uroot -p 为WordPress网站创建数据库。 本教程中数据库名为wordpress。 createdatabasewordpress; 创建一个新用户管理WordPress库，提高安全性。 MySQL在5.7版本后默认安装了密码强度验证插件validate_password。您可以登录MySQL后查看密码强度规则。 showvariableslike\"%password%\";本教程中创建新用户user，新用户密码为PASSword123.。 createuser'user'@'localhost'identifiedby'PASSword123.'; 赋予用户对数据库wordpress的全部权限。 grantallprivilegesonwordpress.*to'user'@'localhost'; 使配置生效。 flush privileges; 退出MySQL。 exit; 下载并解压WordPress，然后移动至网站根目录。 进入Nginx网站根目录，下载WordPress压缩包。 本示例默认安装的是WordPress英文版本。 cd /usr/share/nginx/html wget https://wordpress.org/wordpress-5.4.2.zip 如果您需安装WordPress中文版本，需运行命令wget https://cn.wordpress.org/latest-zh_CN.zip，下载WordPress中文版本压缩包。同时您需要注意，后续操作中压缩包的名称必须替换为latest-zh_CN.zip。 解压WordPress压缩包。 unzip wordpress-5.4.2.zip 将WordPress安装目录下的wp-config-sample.php文件复制到wp-config.php文件中，并将wp-config-sample.php文件作为备份。 cd /usr/share/nginx/html/wordpress cp wp-config-sample.php wp-config.php 编辑wp-config.php文件。 vim wp-config.php 按i键切换至编辑模式，根据已配置的WordPress数据库信息，修改MySQL相关配置信息，修改代码如下所示。 WordPress网站的数据信息将通过数据库的user用户保存在名为wordpress的数据库中。 //**MySQL设置-具体信息来自您正在使用的主机**///** WordPress数据库的名称 */define('DB_NAME','wordpress');/** MySQL数据库用户名 */define('DB_USER','user');/** MySQL数据库密码 */define('DB_PASSWORD','PASSword123.');/** MySQL主机 */define('DB_HOST','localhost'); 修改完成后，按下Esc键后，输入:wq并回车，保存退出配置文件。 安装并登录WordPress网站。 在本地物理机上使用浏览器访问公网IP，进入WordPress安装页面。 填写网站基本信息，然后单击安装WordPress。 填写信息参数说明： 站点标题(Site Title)：WordPress网站的名称。例如：demowp。 用户名(Username)：登录WordPress时所需的用户名，请注意安全性。例如：testwp。 密码(Password)：登录WordPress时所需的密码，建议您设置安全性高的密码。例如：Wp.123456。 您的电子邮件(Your Email)：用于接收通知的电子邮件。例如：1234567890@qq.com。 单击登录。 输入在安装WordPress时设置的用户名testwp和密码Wp.123456，然后单击登录。 成功进入您个人的WordPress网站。 ","date":"2022-10-12","objectID":"/posts/website_lnmp_wordpress/:7:0","tags":["LNMP","Wordpress"],"title":"手动安装LNMP与wordpress","uri":"/posts/website_lnmp_wordpress/"},{"categories":["unity"],"content":"unity字符串拼接的优化相关的一些探索","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"Unity3D优化_字符串拼接0GC Unity3D优化_字符串拼接0GC ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:0:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"字符串池缓存机制 为了避免大型项目中出现巨量的重复字符串，C#底层使用缓存池机制，池中每一个不同内容的字符串存在一个实例。 入池的字符串程序运行期间无法清理。所以并非所有的字符串都自动入池，也并非所有的字符串都需要入池。 所以采用了半自动管理机制，提供了String.Intern和String.IsInterned接口，交给程序员自己维护内部的池。 所以采用了半自动管理机制，提供了字符串。实习生和字符串。 常量(字面值）字符串以及使用\"+“运算符连接的字面值，会被自动加入到缓存池中，以保证相同内容常量值只存在一个实例。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:1:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"String的Intern和IsInterned 字符串调用string.Intern()时，如果自身字面值对应对象已经在池中，则返回指向池内对象的新引用。如果自身字面值不在池中，则将自身加入池中返回自身引用。 字符串调用string.IsInterned()时，如果自身字面值对应对象已在池中，则返回池内对象引用，如果自身字面值不在池中，则返回null ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:2:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"如何产生GC string类提供的拼接，格式化等方法，虽然速度快效率高，但是每次调用时内部都会新建临时变量堆积在内存中，很容易产生GC 字符串就是char[]， 长短发生变化必然要重新分配长度，以及拷贝之前的部分，产生GC 字符串+=拼接会产生装箱，产生GC Append传入值类型数据，会调用ToString方法，需要new string 然后把char[]拷进去，产生堆内存 new StringBuidler 会产生堆内存 string.format内部使用的就是StringBuidler，但是new StringBuidler、Append、ToString都会产生堆内存。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:3:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"StringBuilder Format() StringBuilder 上现有的 AppendFormat() 方法会生成大量垃圾。 那么.NET 以什么方式产生垃圾呢？嗯，参数类型是’object'，由于整数和浮点数经常与 Format() 一起使用，所以你会得到值类型的装箱和拆箱。 还有在“String::ToCharArray()”和“String::CtorCharArrayStartLength()”中进行的临时分配 如果你使用三个以上的参数，也会有更多的垃圾；为此，它需要创建一个临时数组。 看看 StringBuilder 提供的Format() public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0); public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1); public StringBuilder AppendFormat(IFormatProvider provider, string format, params object[] args); public StringBuilder AppendFormat(string format, object arg0); public StringBuilder AppendFormat(string format, object arg0, object arg1); public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2); public StringBuilder AppendFormat(string format, params object[] args); public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2); 这些中的每一个都使用object参数。如果我想传递整数和浮点数，object参数将受制于值类型的装箱和拆箱。还注意到另外一个数组参数params关键词也会造成临时分配，即使不使用object类型。 ‘params’ 关键字实质上将您可能指定的任何参数转换为数组。在这种情况下，整数数组被分配为临时数组，然后被销毁。使用类类型时也会发生同样的事情，而不仅仅是值类型。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:4:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"StringBuidler 与 ToString() C# 中的 StringBuilder 类是处理字符串操作的首选方式,如果你专门使用string类型，则很可能在运行时生成垃圾，但你可以完全避免它。 例如，避免使用“+”运算符连接字符串，c#中字符串是不可变的，这意味着它们不能被修改。如果你执行这种操作，您的结果字符串将被分配在堆上，使用这种代码很容易产生大量垃圾。 StringBuilder 允许您使用可变字符串。它提供将其他字符串和其他类型 连接到可变字符串的功能。StringBuilder 的许多功能是完全无垃圾的。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:5:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"ToString() 调用 ToString() 会产生垃圾吗？ 以下是源码： public override String ToString() { String currentString = m_StringValue; IntPtr currentThread = m_currentThread; if (currentThread != Thread.InternalGetCurrentThread()) { return String.InternalCopy(currentString); } if ((2 * currentString.Length) \u0026lt; currentString.ArrayLength) { return String.InternalCopy(currentString); } currentString.ClearPostNullChar(); m_currentThread = IntPtr.Zero; return currentString; } InternalCopy() 是在堆上分配字符串副本并返回它的函数。该函数实际上可以返回内部字符串而无需进行任何复制。特别是第一次调用时，如果字符串使用了至少 50% 的 StringBuilder 容量。将 ’m_currentThread' 成员设置为零实际上意味着下次在 StringBuilder 上执行任何类型的可变操作时；无论是清除字符串，还是附加到它。StringBuilder 将在堆上分配一个新字符串。StringBuilder 的每个可变方法都会检查“m_currentThread”并确保 StringBuilder 拥有特定的字符串。ToString() 的工作方式是有效地放弃该字符串的所有权，并将在下一个可变操作中从一个新的字符串开始。 这个线程注释背后的原因，以及保持 ToString() 返回的 String 完全不可变，是为了保持 StringBuilder 线程安全。 进行复制的另一个原因是用户对内存的使用效率低下。如果我们只使用 StringBuilder 容量的一小部分，.NET 作者认为返回副本而不是引用完整的大字符串更有效。 如果我想重新使用 StringBuilder 对象，我可能会避免在第一次调用时生成字符串的副本，但是如果我重用 StringBuilder，当我调用它的下一个可变方法时，它会在堆上为我分配一个新字符串。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:6:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"StringBuilder 到 String 没有垃圾 可以做到的是直接访问 StringBuilder 使用的字符串，下面的一个方法它做了一些.net作者不希望你做的事情 string my_string = (string)my_stringbuilder.GetType().GetField( \"m_StringValue\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance ).GetValue( my_stringbuilder ); 该方法并不太好，总归可以去实现。反射再性能方便不太好，所以建议只为您将使用的StringBuilder抓取一次内部字符串。将它作为类的成员或其他东西藏起来，然后您就可以将字符串传递给您希望的任何函数。现在我们不再担心 ToString() 为我们生成垃圾 示例代码： StringBuilder my_stringbuilder = new StringBuilder( 32, 32 ); string my_string = (string)my_stringbuilder.GetType().GetField( \"m_StringValue\", BindingFlags.NonPublic | BindingFlags.Instance ) .GetValue( my_stringbuilder ); my_stringbuilder.Append( \"This \" ); my_stringbuilder.Append( \"Is \" ); my_stringbuilder.Append( \"A \" ); my_stringbuilder.Append( \"Test!\" ); // my string will be \"This Is A Test!\" Console.Write( my_string ); // This second append would have resulted in a new heap allocation // if I'd used ToString() above. my_stringbuilder.Append( \" Yay!\" ); Console.Write( my_string ); 建议使用两个整数参数构造函数创建 StringBuilder 对象。除了预分配字符串外，您还将设置容量上限： // Creates an empty StringBuilder with a minimum capacity of capacity // and a maximum capacity of maxCapacity. public StringBuilder(int capacity, int maxCapacity) 这意味着它的大小永远不会增加，也不会在最初构建后进行更多的堆分配。如果发生这种情况，您抓取的字符串对象将不再链接到 StringBuilder。您需要重做反射调用以获取 StringBuilder 拥有的新字符串。 因此，通过使用该构造函数，这意味着如果您获取内部字符串，则可以保证永远保留对 StringBuilder 可变字符串的引用。不过，这里的一个关键例外是，如果您在另一个线程上使用 StringBuilder。在这种情况下，您将遇到与以前相同的问题。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:7:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"如何优化 例： int a =100; string b = a+\"\"; a+\"\"会产生一次装箱操作，应该改成a.ToString(); 少用string.format，提前缓存共享的StringBuidler对象，避免用的时候产生堆内存。 提前定义好 0 – 9 之间的字符数组，如果传入值类型数据，从高位依次除以10算出每一位的数，然后再去预先声明的0-9字符数组中找对应的char，这样就就不会产生装箱GC了。 如果可以提前确定字符串的长度，可以提前声明一个固定长度的StringBuilder，通过反射取出来内部的_str，这样就可以避免最后的ToString产生的堆内存了。由于_str内容可能无法擦掉之前的所以需要调用GarbageFreeClear();方法。 ","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:8:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["unity"],"content":"使用 StringBuilder 时避免垃圾 StringBuilderExtFormat.zip 无GC代码示例： using System; using System.Text; using UnityEngine; public static class StringBuilderExtensions { // These digits are here in a static array to support hex with simple, easily-understandable code. // Since A-Z don't sit next to 0-9 in the ascii table. private static readonly char[] ms_digits = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; private static readonly uint ms_default_decimal_places = 5; //\u003c Matches standard .NET formatting dp's private static readonly char ms_default_pad_char = '0'; //! Convert a given unsigned integer value to a string and concatenate onto the stringbuilder. Any base value allowed. public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char, uint base_val) { Debug.Assert(pad_amount \u003e= 0); Debug.Assert(base_val \u003e 0 \u0026\u0026 base_val \u003c= 16); // Calculate length of integer when written out uint length = 0; uint length_calc = uint_val; do { length_calc /= base_val; length++; } while (length_calc \u003e 0); // Pad out space for writing. string_builder.Append(pad_char, (int)Math.Max(pad_amount, length)); int strpos = string_builder.Length; // We're writing backwards, one character at a time. while (length \u003e 0) { strpos--; // Lookup from static char array, to cover hex values too string_builder[strpos] = ms_digits[uint_val % base_val]; uint_val /= base_val; length--; } return string_builder; } //! Convert a given unsigned integer value to a string and concatenate onto the stringbuilder. Assume no padding and base ten. public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val) { string_builder.Concat(uint_val, 0, ms_default_pad_char, 10); return string_builder; } //! Convert a given unsigned integer value to a string and concatenate onto the stringbuilder. Assume base ten. public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount) { string_builder.Concat(uint_val, pad_amount, ms_default_pad_char, 10); return string_builder; } //! Convert a given unsigned integer value to a string and concatenate onto the stringbuilder. Assume base ten. public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char) { string_builder.Concat(uint_val, pad_amount, pad_char, 10); return string_builder; } //! Convert a given signed integer value to a string and concatenate onto the stringbuilder. Any base value allowed. public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char, uint base_val) { Debug.Assert(pad_amount \u003e= 0); Debug.Assert(base_val \u003e 0 \u0026\u0026 base_val \u003c= 16); // Deal with negative numbers if (int_val \u003c 0) { string_builder.Append('-'); uint uint_val = uint.MaxValue - ((uint)int_val) + 1; //\u003c This is to deal with Int32.MinValue string_builder.Concat(uint_val, pad_amount, pad_char, base_val); } else { string_builder.Concat((uint)int_val, pad_amount, pad_char, base_val); } return string_builder; } //! Convert a given signed integer value to a string and concatenate onto the stringbuilder. Assume no padding and base ten. public static StringBuilder Concat(this StringBuilder string_builder, int int_val) { string_builder.Concat(int_val, 0, ms_default_pad_char, 10); return string_builder; } //! Convert a given signed integer value to a string and concatenate onto the stringbuilder. Assume base ten. public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount) { string_builder.Concat(int_val, pad_amount, ms_default_pad_char, 10); return string_builder; } //! Convert a given signed integer value to a string and concatenate onto the stringbuilder. Assume base ten. public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char) { string_builder.Concat(int_val, pad_amount, pad_char, 10); return string_builder; } //! Co","date":"2021-08-11","objectID":"/posts/unity3d_stringbuilder/:9:0","tags":["StringBuilder","unity","GC"],"title":"Unity3D优化_字符串拼接0GC","uri":"/posts/unity3d_stringbuilder/"},{"categories":["tools"],"content":"PotPlayer不支持S/W HEVC(H.265)格式的视频播放解决方案","date":"2021-08-07","objectID":"/posts/tools_potplayerh265/","tags":["PotPlayer"],"title":"PotPlayer不支持S/W HEVC(H.265)解码","uri":"/posts/tools_potplayerh265/"},{"categories":["tools"],"content":"PotPlayer播放MKV格式的视频时跳出视窗显示：不支持S/W HEVC(H.265)解码 ","date":"2021-08-07","objectID":"/posts/tools_potplayerh265/:0:0","tags":["PotPlayer"],"title":"PotPlayer不支持S/W HEVC(H.265)解码","uri":"/posts/tools_potplayerh265/"},{"categories":["tools"],"content":"解决办法 1 首先下载 FFMPEG64.DLL 解压下载的压缩包 将文件复制到安装路径D:\\MyProgram Files\\DAUM\\PotPlayer\\Module\\FFmpeg4下(安装路径视实际情况而定) 打开PotPlayer,点击选项（或者直接按F5），打开设置 选择滤镜-视频解码器-内置解码器/DXVA设置 将左边的「H.265/HEVC」从「内建FFmpeg解码器(建议)」改成「FFmpeg64.dll」 确定之后重新打开就行 ","date":"2021-08-07","objectID":"/posts/tools_potplayerh265/:1:0","tags":["PotPlayer"],"title":"PotPlayer不支持S/W HEVC(H.265)解码","uri":"/posts/tools_potplayerh265/"},{"categories":["tools"],"content":"解决办法 2 直接点弹出提示中的 搜索解码器 冲github中下载installer.exe文件 自定义安装刚下载好的exe文件 以防万一安装中的选项直接全选 完成后打开potplayer,打开选项-滤镜-全局滤镜优先权 点击 添加系统滤镜 打开窗口 如果安装成功会出现“LAV Audio Decoder”、“LAV Splitter”、“LAV Splitter Source”、“LAV Video Decoder”四项,否则安装没成功. 选中 LAV Splitter Source 然后确定. 然后在配置窗口中勾选中LAV Splitter Source,优先顺序改成 强制使用 并应用 按上面的操作依次添加 LAV Video Decoder 和 LAV Audio Decoder 然后选择左侧菜单栏的 滤镜 选项,将激活条件选择为不使用,将使用声音处理过滤(推荐) 前的勾选去掉,然后应用. 到这里重新打开视频就可以正常播放了,此时按 Ctrl+F1 快捷键调出播放信息窗口,可以看滤镜列表中启用了刚添加的3项 ","date":"2021-08-07","objectID":"/posts/tools_potplayerh265/:2:0","tags":["PotPlayer"],"title":"PotPlayer不支持S/W HEVC(H.265)解码","uri":"/posts/tools_potplayerh265/"},{"categories":["study"],"content":"二进制数复习指南，回顾二进制的计算与使用","date":"2021-08-06","objectID":"/posts/study_binary/","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"原码、反码、 补码 在计算机中，用来表示有符号数的机器数有三种，即原码、反码、补码，三种表示方法均有“符号位” 和“数值位”两部分 符号位都是占据最高位，用0表示 '正数' ,用1表示'负数' 数值位，三种表示方式各不相同 正数：原码、反码、补码都一样 真值：3 原码：0000 0011 最高位为0，表示正数 反码：0000 0011 补码：0000 0011 负数：原码、反码、补码不一样 真值：-3 原码：1000 0011 最高位为1表示负数 反码：1111 1100 由原码转化，原码的符号位不变，数值位全部取反 补码：1111 1101 由反码的基础上+1得到 在计算机系统中，数值一律用补码来存储！ 主要原因：使用补码，可以将符号位和其他位统一处理；同时减法也可按加法来处理(如2-1等于2+(-1)) 需要注意的是两个补码表示的数相加时，如果最高位(符号位)有进位，则会把进位舍弃，处理完成后我们如上面所示用补码反推出真值即可 举个栗子 第一步：真值-\u003e原码-\u003e反码-\u003e补码 真值：8 原码：0000 1000 反码：0000 1000 补码：0000 1000 真值：-3 原码：1000 0011 反码：1111 1100 补码：1111 1101 第二步：补码之间的运算，此处为相加 8的补码：0000 1000 -3的补码：1111 1101 相加得补码：0000 0101 # 补码相加，高位有进位会被舍弃 第三步：补码-\u003e反码-\u003e原码-\u003e真值 上一步得到的补码结果：0000 0101 符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位 补码-\u003e反码-\u003e原码：0000 0101 原码-\u003e真值：5 ","date":"2021-08-06","objectID":"/posts/study_binary/:1:0","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"位运算符 按位与\u0026：两位全为1，结果才为1，否则为0 按位或|：两位只要存在一个1，结果就为1，否则为0 按位异或^：只有在两位不相同，即一个为0一个为1的情况下，结果才为1，否则为0 («) n：各二进制位全部左移n位，高位丢弃，低位补0 (») n: 各二进制位全部右移n位，如果是正数，则高位补0，如果是负数则高位补1 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:0","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"按位与\u0026 位与(\u0026)是一个双目运算符，也就是说\u0026符号的左右各有一个操作数。它是把两个操作数在二进制的形式上按位进行比较 按位与\u0026：两位全为1，结果才为1，否则为0 示例1:8 \u0026 -3 计算8\u0026-3 第一步：真值\u003e原码\u003e反码\u003e补码 真值：8 原码：0000 1000 反码：0000 1000 补码：0000 1000 真值：-3 原码：1000 0011 反码：1111 1100 补码：1111 1101 第二步：补码之间的运算，此处为\u0026 8的补码：0000 1000 -3的补码：1111 1101 \u0026得补码：0000 1000 第三步：补码\u003e反码\u003e原码\u003e真值 上一步得到的补码结果：0000 1000 符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位 补码\u003e反码\u003e原码：0000 1000 原码-\u003e真值：8 示例2:-9\u0026-8 计算-8\u0026-9 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 真值：-9 原码：1000 1001 反码：1111 0110 补码：1111 0111 第二步：补码之间的运算，此处为\u0026 -8的补码：1111 1000 -9的补码：1111 0111 \u0026得补码：1111 0000 第三步：补码\u003e反码\u003e原码\u003e真值 补码-\u003e反码 补码结果：1111 0000 符号位是1，为负数，参照上面的步骤 补码\u003e反码：-1，得到反码：1110 1111 反码\u003e原码：符号位不变，其余位取反，得到原码：1001 0000 原码\u003e真值：-16 应用 逻辑与(\u0026\u0026)的替代使用： 逻辑与(\u0026\u0026)有一个特点就是短路，而位与(\u0026)就没有短路的效果 当需求不管第1个表达式的结果如何，都必须要运算第2个表达式的时候就可以用 \u0026 取代 \u0026\u0026 利用 \u0026 运算符的特性，来判断二进制数第一位是0还是1 用/if ((a \u0026 1)==0)/代替/if (a % 2 == 0)/来判断a是不是偶数。 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:1","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"按位或 | 位或(|)也是一个双目运算符。它是把两个操作数在二进制的形式上按位进行比较 按位或|：两位只要存在一个1，结果就为1，否则为0 示例1:-8|-9 计算-8|-9 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 真值：-9 原码：1000 1001 反码：1111 0110 补码：1111 0111 第二步：补码之间的运算，此处为| -8的补码：1111 1000 -9的补码：1111 0111 |得补码：1111 1111 第三步：补码\u003e反码\u003e原码\u003e真值 补码\u003e反码 补码结果：1111 1111 符号位是1，为负数，参照上图2的步骤 补码\u003e反码：-1，得到反码：1111 1110 反码\u003e原码：符号位不变，其余位取反，得到原码：1000 0001 原码\u003e真值：-1 应用 逻辑或 || 的替代 使用位或 | 操作boolean表达式的时候，效果与逻辑或 || 一样，且没有短路效果 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:2","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"按位异或^ 按位异或^：只有在两位不相同，即一个为0一个为1的情况下，结果才为1，否则为0 示例1：-8 ^ -9 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 真值：-9 原码：1000 1001 反码：1111 0110 补码：1111 0111 第二步：补码之间的运算，此处为^ -8的补码：1111 1000 -9的补码：1111 0111 ^得补码：0000 1111 第三步：补码\u003e反码\u003e原码\u003e真值 上一步得到的补码结果：0000 1111 符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位 补码\u003e反码\u003e原码：0000 1111 原码\u003e真值：15 示例2:^ -8 单独一个^代表取反的意思 计算:^ -8 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 第二步： -8的补码：1111 1000 ^取反得补码：0000 0111 第三步：补码\u003e反码\u003e原码\u003e真值 上一步得到的补码结果：0000 0111 符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位 补码\u003e反码\u003e原码：0000 0111 原码\u003e真值：7 应用 异或(^)运算有两个非常有趣的结论： 任何一个数异或(^)它本身，结果是0； 任何一个数异或(^)0，结果是它本身。 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:3","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"向左位移« n « n：各二进制位全部左移n位，高位丢弃，低位补0 示例1：-8 \u003c\u003c 3 计算-8\u003c\u003c3 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 第二步：\u003c\u003c n 各二进制位全部左移n位，高位丢弃，低位补0 补码：1111 1000 \u003c\u003c3: 1100 0000 第三步：补码\u003e反码\u003e原码\u003e真值 补码-\u003e反码 补码结果：1100 0000 符号位是1，为负数，参照上图2的步骤 补码-\u003e反码：-1，得到反码：1011 1111 反码-\u003e原码：符号位不变，其余位取反，得到原码：1100 0000 原码-\u003e真值：-64 应用 将一个数左移(«)n位，相当于乘以了2的n次方。这种运算在效率和性能上都比算术运算中的要高很多。 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:4","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"向右位移(») n (») n: 各二进制位全部右移n位，如果是正数，则高位补0，如果是负数则高位补1 示例1：-8 \u003e\u003e 3 计算-8\u003e\u003e3 第一步：真值\u003e原码\u003e补码 真值：-8 原码：1000 1000 反码：1111 0111 补码：1111 1000 第二步：\u003e\u003e n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负数则高位补1 补码：1111 1000 \u003e\u003e3: 1111 1111 第三步：补码\u003e反码\u003e原码\u003e真值 补码-\u003e反码 补码结果：1111 1111 符号位是1，为负数，参照上图2的步骤 补码-\u003e反码：-1，得到反码：1111 1110 反码-\u003e原码：符号位不变，其余位取反，得到原码：1000 0001 原码-\u003e真值：-1 示例2：8 \u003e\u003e 3 计算8\u003e\u003e3 第一步：真值\u003e原码\u003e补码 真值：8 原码：0000 1000 反码：0000 1000 补码：0000 1000 第二步：\u003e\u003e n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负责则高位补1 补码：0000 1000 \u003e\u003e3: 0000 0001 第三步：补码\u003e反码\u003e原码\u003e真值 上一步得到的补码结果：0000 0001 符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位 补码\u003e反码\u003e原码：0000 0001 原码-\u003e真值：1 示例3：-300 \u003e\u003e 8 计算-300\u003e\u003e8 第一步：真值\u003e原码\u003e补码 真值：-300 原码：1000 0001 0010 1100 # -300 已经超过了8位二进制能表示的范围，需要用16位表示 反码：1111 1110 1101 0011 补码：1111 1110 1101 0100 第二步：\u003e\u003e n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负责则高位补1 补码：1111 1110 1101 0100 \u003e\u003e8: 1111 1111 1111 1110 第三步：补码-\u003e反码-\u003e原码-\u003e真值 补码\u003e反码 补码结果：1111 1111 1111 1110 符号位是1，为负数，参照上图2的步骤 补码\u003e反码：-1，得到反码：1111 1111 1111 1101 反码\u003e原码：符号位不变，其余位取反，得到原码：1000 0000 0000 0010 原码-\u003e真值：-2 应用 将一个数右移n位，相当于除以2的n次方取整。这种运算在效率和性能上都比算术运算中的要高很多。 注意： 右移正整数会有除法的效果，但是右移负整数得到的结果会比除法的效果要小一个数。 13»2得到3 13/4得到3 -13»2得到-4 -13/4得到-3 这是因为计算机在除不尽的时候统统采用的是向下取整，而我们人则习惯于直接去掉小数部分 ","date":"2021-08-06","objectID":"/posts/study_binary/:2:5","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"\u0026 0xff 的作用 首先我们都知道，\u0026 表示按位与，只有两个位同时为1，才能得到1，0x代表16进制数，0xff数的二进制 1111 1111 占一个字节。与其进行 \u0026 操作的数，最低的8位不会发生变化。 下面说说\u00260xff的应用： ","date":"2021-08-06","objectID":"/posts/study_binary/:3:0","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["study"],"content":"为了取得低八位 通常配合移位操作符 » 使用 例如：有一个数字0x1234,如果只想将低8位写入到内存中 0x1234\u00260xff 0x1234 表示为二进制 0001 0010 0011 0100 0xff 表示为二进制 1111 1111 两个数做与操作，显然将0xff补充到16位，就是高位补0 此时0xff 为 0000000011111111 与操作 1\u00260 =0 1\u00261 =1 这样 0x1234只能保留低八位的数 0000000000110100 也就是 0x34 ","date":"2021-08-06","objectID":"/posts/study_binary/:3:1","tags":["二进制","binary"],"title":"二进制数与位运算","uri":"/posts/study_binary/"},{"categories":["unity"],"content":"通过apk包找出dll文件并反编译出代码","date":"2021-08-06","objectID":"/posts/unity3d_opendll/","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["unity"],"content":"DLL反编译工具 dnSpy ","date":"2021-08-06","objectID":"/posts/unity3d_opendll/:1:0","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["unity"],"content":"unity il2cpp apk 反汇编 ","date":"2021-08-06","objectID":"/posts/unity3d_opendll/:2:0","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["unity"],"content":"unity apk会出现两种情况 解压后asset-\u003ebin-\u003eData-\u003eManaged中有很多dll,这是用unity mono打包的，直接用dnspy/Reflector等工具打开Assembly-CSharp.dll即可 解压后asset-\u003ebin-\u003eData-\u003eManaged中有3个文件夹etc、Metadata、Resources,这是使用unity新版的il2cpp模式打包的，使用以下流程破解（破解后的Assembly-CShapr.dll依旧无法看到代码，会被转成16进制文件存储，反编译好像没什么意义，当然小部分项目由于使用的unity版本过旧依旧可以查看代码，可以先查看下apk使用的unity版本再决定是否需要反汇编） ","date":"2021-08-06","objectID":"/posts/unity3d_opendll/:2:1","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["unity"],"content":"针对第二种情况(无法看到代码) 下载il2cppDumper 将应用apk重命名，后缀名为.rar,并解压 运行il2CppDumper.exe 在apk解压的文件夹中，找到asset-\u003ebin-\u003eData,随便用文本框打开一个文件，可以看到一堆乱码，但第一行会有几个数字，比如2019.1.12f1即为版本号 在il2CppDumper.exe中要求找到 ，apk解压的文件夹中lib–\u003earm64–\u003elibil2cpp. so,（arm64名字可能不一样，找到最后的libil2cpp.so即可，会有多个libil2cpp.so文件，随便选择一个即可） 在il2CppDumper.exe中要求找到 ，apk解压的文件夹中assets-\u003ebin-\u003eData-\u003eManaged-\u003eMetadata-\u003eglobal-metadata.dat文件 出现要求输入版本号，输入步骤4找到的版本号，如：2019.1.12/2019.1.12f1都可，回车，出现 select Mode: i.Manua1 2.Auto 3.Auto(Plus)4.Auto(Symbo1) 选择3，等待一会，就会在il2CppDumper.exe同级目录下生成dump.cs、script. py、DummyDll文件，如果失败可以依次尝试其它模式 最后使用dnspy/Reflector等工具打开Assembly-CSharp.dll即可 ","date":"2021-08-06","objectID":"/posts/unity3d_opendll/:2:2","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["unity"],"content":"其他 unity版本输入不正确时，会出现：System.IndexOutOfRangeException: 索引超出了数组界限。也可能会出现该模式不可使用，要求尝试其它模式的提醒 选择1,地址输入不正确时会出现只生成dump.cs和script.py文件而不生成DummyDll文件夹的情况（实际上dump.cs里也只有一些注释，生成错误） ","date":"2021-08-06","objectID":"/posts/unity3d_opendll/:3:0","tags":["dnSpy","dll"],"title":"反编译apk内dll的代码","uri":"/posts/unity3d_opendll/"},{"categories":["health"],"content":"铁蛋白是人体内的一种蛋白质，帮助贮存身体组织内的铁","date":"2021-08-06","objectID":"/posts/health_1/","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"如何提升铁蛋白原文 ","date":"2021-08-06","objectID":"/posts/health_1/:0:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"如何提升铁蛋白 铁蛋白是人体内的一种蛋白质，帮助贮存身体组织内的铁。如果出现缺铁或营养不良，铁蛋白水平可能会降低。此外，还有各种各样的身体状况和慢性疾病会降低铁蛋白水平。虽然铁蛋白水平低会引起严重的健康问题，但在多数情况下，铁蛋白水平很容易提高。找出潜在的健康问题，服用补充剂和改变饮食，就能够增加血液中的铁蛋白水平。 ","date":"2021-08-06","objectID":"/posts/health_1/:1:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"第一部分：找出铁蛋白水平低的原因 ","date":"2021-08-06","objectID":"/posts/health_1/:2:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"1.咨询医生 在自行采取行动提升铁蛋白水平之前，应先咨询医生。医生会询问个人和家庭病史，还有你是否出现与铁蛋白水平低相关的症状。这些症状包括：[1] 疲劳 头痛 烦躁 脱发 指甲易断 气短 ","date":"2021-08-06","objectID":"/posts/health_1/:2:1","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"2.检测血液中的铁含量 由于铁蛋白是人体组织吸收的铁，因此医生首先会检测你血液中的铁含量，看一下你是否摄入足够的铁，或是否有抑制血液吸收铁的状况。[2] ","date":"2021-08-06","objectID":"/posts/health_1/:2:2","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"3.检测铁蛋白水平 医生还会检查你的铁蛋白水平。如果血液中的铁含量不足，身体会从组织中吸收，从而降低铁蛋白水平。因此，铁蛋白水平测试和铁水平测试通常会同时进行。[3] 每毫升血液中应有30-40ng的铁蛋白。低于20ng被视为轻度铁蛋白不足。[4]低于10ng为铁蛋白不足。 一些化验室使用不同的测试方法，给出的正常铁蛋白水平和范围也会有所不同。因此，一定要向医生咨询检测结果。 ","date":"2021-08-06","objectID":"/posts/health_1/:2:3","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"4.测试铁的结合能力 该测试将会测量血液最多可以储存多少铁。有关结果可以让医生了解你的肝脏和其它器官是否正常运作。如果出现问题，铁蛋白或铁水平低可能是严重问题引发的。[5] ","date":"2021-08-06","objectID":"/posts/health_1/:2:4","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"5.确定是否患有严重的疾病 医生在访问病史和验血过后，会确定你是否患有导致低铁蛋白水平或影响铁蛋白升高的疾病。可能影响铁蛋白水平或治疗方案的疾病包括但并不仅限于： 贫血 癌症 肾脏疾病 肝炎 胃溃疡 酶紊乱[6] ","date":"2021-08-06","objectID":"/posts/health_1/:2:5","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"第二部分：服用补剂 ","date":"2021-08-06","objectID":"/posts/health_1/:3:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"1.口服铁质补剂 如果你患上轻度或中度铁蛋白缺乏症，医生可能建议你去本地杂货店或药房购买铁质补剂，按照产品说明或医生建议服用。通常服用铁质补剂几周后，铁和铁蛋白水平才会上升。 铁补剂可能引起一些副作用，如背痛、发冷、头晕、头疼和恶心。[7] 由于维生素C可以提升血液对铁的吸收，你可以用橙汁送服铁补剂。[8] 服用铁补剂时，不要同时服用牛奶、咖啡、抗酸药或钙补充剂。这些物质会降低铁的吸收。[9] ","date":"2021-08-06","objectID":"/posts/health_1/:3:1","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"2.注射维生素和静脉输铁 如果是重度铁蛋白缺乏症、流失了大量血液或身体无法吸收铁，医生会让你接受注射或输液。医生可能直接将铁注射到血液，或注射维生素B12，促进铁吸收。如果状况严重，医生可能建议输血，以尽快提升铁水平。[10] 其它方法无法有效补充铁或铁蛋白水平时，才可进行注射或输液。 铁注射的副作用与口服补剂类似。 ","date":"2021-08-06","objectID":"/posts/health_1/:3:2","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"3.靠处方补剂和药物提高铁蛋白水平 有很多药物可以提升人体的铁和铁蛋白水平。如果你的身体无法吸收或贮存铁，医生可能会给你开一些药，包括： 硫酸亚铁 葡萄糖酸亚铁 富马酸亚铁 羰基铁 铁右旋糖酐复合物[11] ","date":"2021-08-06","objectID":"/posts/health_1/:3:3","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"第三部分：改变饮食 ","date":"2021-08-06","objectID":"/posts/health_1/:4:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"1.多吃肉 肉是铁质的最好来源，尤其是红肉。这不仅因为肉类富含铁质，而且人体更容易吸收来自肉类的铁质。因此只要多吃肉，就可以增加铁和铁蛋白水平。对增加铁水平最有效的肉类产品包括： 牛肉 羊肉 肝脏 贝类 蛋类[12] ","date":"2021-08-06","objectID":"/posts/health_1/:4:1","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"2.多吃富含铁的植物食品 除了肉类，很多植物食品也富含铁。多吃这类植物食品也可以帮助增加血液中的铁蛋白水平。不过要想获得等量的铁质，你需要吃的植物食品是肉类的两倍。富含铁的植物食品包括： 菠菜 小麦 燕麦 坚果 米饭 （经过营养强化） 豆类[13] ","date":"2021-08-06","objectID":"/posts/health_1/:4:2","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"3.减少摄入可能阻碍身体吸收铁的食物和矿物质 一些食物和矿物质可能会使身体难以消化和吸收铁质。不过也没必要完全不吃这类食物，只要减少摄入就好： 红酒 咖啡 红茶和绿茶 非发酵豆制品[14] 牛奶 钙 镁 锌 铜[15] ","date":"2021-08-06","objectID":"/posts/health_1/:4:3","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["health"],"content":"参考文献 http://www.mayoclinic.org/tests-procedures/ferritin-test/home/ovc-20271871 https://www.mayoclinic.org/tests-procedures/ferritin-test/details/results/rsc-20271960 https://medlineplus.gov/ency/article/003489.htm http://www.irondisorders.org/therapies-to-increase-iron http://www.mayoclinic.org/drugs-supplements/iron-supplement-oral-route-parenteral-route/side-effects/drg-20070148 https://my.clevelandclinic.org/health/articles/oral-iron-supplementation http://www.irondisorders.org/therapies-to-increase-iron http://emedicine.medscape.com/article/202333-medication#2 http://www.redcrossblood.org/learn-about-blood/health-and-wellness/iron-rich-foods.html https://www.insidetracker.com/blog/post/56962740603/got-fatigue-increase-your-ferritin# https://snappyliving.com/5-foods-to-avoid-if-you-have-anemia/ http://www.parentingscience.com/iron-absorption.html ","date":"2021-08-06","objectID":"/posts/health_1/:5:0","tags":["铁蛋白"],"title":"如何提升铁蛋白","uri":"/posts/health_1/"},{"categories":["tools"],"content":"通过网站链接下载网站内的视频到本地磁盘","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl 主页 youtube-dl github文档 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:0:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl 视频下载工具 解决平常看到想要下载保存到本地的视频，然而视频网站一般不提供下载接口，这时候需要 借助工具来完成，而youtube-dl刚好能够解决该痛点。 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:1:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl 安装 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:2:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"MAC 端 Mac系统自带python2，所以无需再安装python 调出终端输入： brew install youtube-dl 或者 port install youtube-dl 取决与你电脑安装的工具 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:2:1","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"Windows 端 先去官网安装Python3 Python下载官网：https://www.python.org/downloads/windows/ 下载后，安装的时候记得一定勾选配置环境变量 完成后检测是否安装成功： 按win+R，调出运行，输入cmd回车，再输入 python 如果安装成功会显示版本等信息 成功后输入命令： exit() 退出交互端口 装好python后开始安装主角youtube-dl 调用pip安装： pip install youtube-dl 回车后会出现下载进度与安装提示 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:2:2","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl使用 列出支持的网站，终端输入： youtube-dl --list-extractors 下载视频，终端输入： youtube-dl “视频链接” 如：youtube-dl \"www.google.com\" 列出所有视频格式，终端输入： youtube-dl -F \"视频链接\" 如：youtube-dl -f \"www.google.com\" 从列表中进行下载 youtube-dl -f “视频编码” “视频链接” 如：youtube-dl -f 1 \"www.google.com\" 下载到指定目录 youtube-dl -o “绝对目录” “视频链接” 如：youtube-dl -o '\\999\\' 'www.google.com' ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:3:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl配置 您可以通过将任何受支持的命令行选项放入配置文件来配置 youtube-dl。在 Linux 和 macOS 上，系统范围的配置文件位于 ，/etc/youtube-dl.conf用户范围的配置文件位于~/.config/youtube-dl/config. 在 Windows 上，用户范围的配置文件位置是%APPDATA%\\youtube-dl\\config.txt或C:\\Users\\\u003cuser name\u003e\\youtube-dl.conf。请注意，默认配置文件可能不存在，因此您可能需要自己创建它。 例如，使用以下配置文件 youtube-dl 将始终提取音频，而不是复制 mtime，使用代理并将所有视频保存Movies在您的主目录中的目录下： # Lines starting with # are comments # Always extract audio -x # Do not copy the mtime --no-mtime # Use this proxy --proxy 127.0.0.1:3128 # Save all videos under Movies directory in your home directory -o ~/YoutubeDlMovies/%(title)s.%(ext)s 下载视频的格式配置示例： 在 Windows 上，您可能需要使用双引号而不是单引号。 #下载可用的最佳 mp4 格式或任何其他最佳格式（如果没有可用的 mp4） #-f ' bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best ' #下载最好的格式，但不超过 480p #-f ' bestvideo[height\u003c=480]+bestaudio/best[height\u003c=480] ' #下载最佳视频格式但不超过 50 MB #-f ' best[filesize\u003c50M] ' #通过直接链接通过 HTTP/HTTPS 协议下载可用的最佳格式 #-f ' (bestvideo+bestaudio/best)[protocol^=http] ' #下载最好的视频格式和最好的音频格式而不合并它们 #-f ' bestvideo,bestaudio ' -o ' %(title)sf%(format_id)s.%(ext)s ' 请注意，配置文件中的选项与常规命令行调用中使用的选项即开关相同，因此 - 或 -- 后不得有空格，例如 -o 或 --proxy 不是 - o 或 -- proxy. --ignore-config如果要禁用特定 youtube-dl 运行的配置文件，则可以使用。 --config-location如果要为特定的 youtube-dl 运行使用自定义配置文件，也可以使用。 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:4:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"youtube-dl更新 pip install --upgrade youtube-dl 如youtube-dl官网所述，使用pip是一种安装youtube-dl的方法，该选项可确保您最终安装了最新的可用版本。 要了解youtube-dl的版本与安装位置，可以使用pip show youtube-dl命令 ","date":"2021-08-06","objectID":"/posts/tools_youtube-dl/:5:0","tags":["youtube-dl"],"title":"youtube-dl下载利器","uri":"/posts/tools_youtube-dl/"},{"categories":["tools"],"content":"python的pip版本过低导致使用异常","date":"2021-08-06","objectID":"/posts/tools_pythonuppip/","tags":["python","pip"],"title":"python升级pip","uri":"/posts/tools_pythonuppip/"},{"categories":["tools"],"content":"使用pip时报错 WARNING: You are using pip version 20.2.4, however version 21.2.2 is available. You should consider upgrading via the ‘python -m pip install –upgrade pip’ command. 提示正在使用的版本20.2.4，新版本21.2.2，需要升级pip版本 ","date":"2021-08-06","objectID":"/posts/tools_pythonuppip/:0:0","tags":["python","pip"],"title":"python升级pip","uri":"/posts/tools_pythonuppip/"},{"categories":["tools"],"content":"升级pip 在命令操作窗口输入 python -m pip install --upgrade pip 之后等待下载安装，可能会有点久，一直等待就行。 成功之后会提示成功升级到某个新版本：Successfully installed pip-21.2.2 ","date":"2021-08-06","objectID":"/posts/tools_pythonuppip/:0:1","tags":["python","pip"],"title":"python升级pip","uri":"/posts/tools_pythonuppip/"},{"categories":["tools"],"content":"查看pip版本 如果不知道版本可通过命令： pip show pip ","date":"2021-08-06","objectID":"/posts/tools_pythonuppip/:0:2","tags":["python","pip"],"title":"python升级pip","uri":"/posts/tools_pythonuppip/"},{"categories":["buildwebsite"],"content":"Valine出现Code403访问被api域名白名单拒绝","date":"2021-08-06","objectID":"/posts/website_valinecode403/","tags":["Code403","Valine"],"title":"Valine出现Code403访问被api域名白名单拒绝","uri":"/posts/website_valinecode403/"},{"categories":["buildwebsite"],"content":"Code 403: 访问被API域名白名单拒绝，请检查你的安全域名设置 ","date":"2021-08-06","objectID":"/posts/website_valinecode403/:0:0","tags":["Code403","Valine"],"title":"Valine出现Code403访问被api域名白名单拒绝","uri":"/posts/website_valinecode403/"},{"categories":["buildwebsite"],"content":"解决办法： 在leancloud的评论应用\u003e设置\u003e安全中心\u003eWeb安全域名中修改新的域名如： https://www.iubucuoo.com https://iubucuoo.com ","date":"2021-08-06","objectID":"/posts/website_valinecode403/:0:1","tags":["Code403","Valine"],"title":"Valine出现Code403访问被api域名白名单拒绝","uri":"/posts/website_valinecode403/"},{"categories":["buildwebsite"],"content":"使用Algolia在网站中添加搜索系统","date":"2021-08-06","objectID":"/posts/website_addangolia/","tags":["hugo","Algolia"],"title":"hugo添加Algolia搜索系统","uri":"/posts/website_addangolia/"},{"categories":["buildwebsite"],"content":"其他教程： Hugo添加Algolia搜索支持 折腾Hugo的loveit主题 ","date":"2021-08-06","objectID":"/posts/website_addangolia/:0:0","tags":["hugo","Algolia"],"title":"hugo添加Algolia搜索系统","uri":"/posts/website_addangolia/"},{"categories":["buildwebsite"],"content":"注册Algolia 注册Algolia ","date":"2021-08-06","objectID":"/posts/website_addangolia/:1:0","tags":["hugo","Algolia"],"title":"hugo添加Algolia搜索系统","uri":"/posts/website_addangolia/"},{"categories":["buildwebsite"],"content":"生成索引文件 首先修改 config.toml文件 [outputs] home = [\"HTML\", \"RSS\", \"Algolia\"] [outputFormats.Algolia] baseName = \"algolia\" isPlainText = true mediaType = \"application/json\" notAlternative = true [params.algolia] appId = \"Application ID\" indexName = \"索引名字\" searchOnlyKey = \"Search-Only API Key\" 注:[outputs]下home内必需有\"Algolia\"，id与key等使用注册Algolia分配的。 执行hugo命令algolia.json会生成在public目录下 ","date":"2021-08-06","objectID":"/posts/website_addangolia/:2:0","tags":["hugo","Algolia"],"title":"hugo添加Algolia搜索系统","uri":"/posts/website_addangolia/"},{"categories":["buildwebsite"],"content":"上传索引文件 手动 在Algolia网站内，点测栏Indices，再点Upload record按钮上传生成的algolia.json文件。 自动 (命令行执行) 每次更新都需要手动比较麻烦，可以采用自动的配置，在本地安装相关工具实现 使用atomic-algolia工具来处理 安装npm 安装atomic-algolia： npm init #用来生成package.json的 npm install atomic-algolia --save-dev 执行后打开package.json，在scripts部分后面添加一句\"algolia\": \"atomic-algolia\",添加之后像这样: \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 之后还需要新建一个.env文件，添加一下信息： ALGOLIA_APP_ID={{ YOUR_APP_ID }} ALGOLIA_ADMIN_KEY={{ YOUR_ADMIN_KEY }} ALGOLIA_INDEX_NAME={{ YOUR_INDEX_NAME }} ALGOLIA_INDEX_FILE=public/algolia.json 填写并保存之后，尝试把索引提交给Algolia: npm run algolia 之后再每次执行hugo生成public文件命令后跟一句该语句执行上传就可以了 ","date":"2021-08-06","objectID":"/posts/website_addangolia/:3:0","tags":["hugo","Algolia"],"title":"hugo添加Algolia搜索系统","uri":"/posts/website_addangolia/"},{"categories":["buildwebsite"],"content":"在网页中嵌入视频","date":"2021-08-05","objectID":"/posts/website_video/","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"在 md 文件中嵌入 ShortCodes 时，其查找顺序如下： /layouts/shortcodes/\u003cSHORTCODE\u003e.html /themes/\u003cTHEME\u003e/layouts/shortcodes/\u003cSHORTCODE\u003e.html 即优先查找你的项目的根目录下的 /layouts/shortcodes 文件夹下的模板文件，再查找 theme 文件夹下的 /layouts/shortcodes 文件夹。 ","date":"2021-08-05","objectID":"/posts/website_video/:0:0","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"1. 创建 html 模板 我们在 /layouts/shortcodes/ 目录下创建一个 bilibili.html 并粘贴下面的代码： \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003c!-- style 样式 是为了让网页上的视频框按比例显示而非固定的大小 --\u003e \u003cstyle type=\"text/css\"\u003e .aspect-ratio { position: relative; width: 100%; height: 0; padding-bottom: 75%; } .aspect-ratio iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"aspect-ratio\"\u003e \u003ciframe src=\"https://player.bilibili.com/player.html?bvid={{.Get 0 }}\u0026page={{ if .Get 1 }}{{.Get 1}}{{ else }}1\u0026high_quality=1\u0026danmaku=0{{end}}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\" \u003e \u003c/iframe\u003e \u003c!-- src 中的 \u0026high_quality=1\u0026danmaku=0 设定了高清程度并默认屏蔽弹幕 --\u003e \u003c!-- sandbox 阻止了点击视频中的按钮跳转到B站的行为 --\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-08-05","objectID":"/posts/website_video/:1:0","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"关于B站链接的参数介绍 B站的链接有点薛定谔，不同的视频显示的链接参数不尽相同，但是总的来说有以下类型： key 说明 cid chat id，每个 chat id 对应一组弹幕池如填了 aid ，这个字段不填也没关系 aid article id ，视频的 av 号就是B站的 avxxxx 后面的数字 bvid bilibili video id ，视频的 bv 号2020.03 时候，B战把 av 号根据一定的算法转成这个了如果填了 bvid ，那么 aid 不填也可以 page 第几个视频，起始下标为 1 （默认值也是为1）就是B站视频，选集里的第几个视频 as_wide 是否宽屏1: 宽屏，0: 小屏 high_quality 是否高清1: 高清，0: 最低视频质量（默认）如视频有 360P 720P 1080P 三种，默认或者 high_quality=0 是最低 360P high_quality=1 是最高1080P danmaku 是否开启弹幕1: 开启（默认），0: 关闭 t 打开时，自动跳转到某个时间，并且自动播放（单位秒）比如 t=60 ，那么自动跳转到1分钟，且自动播放 ","date":"2021-08-05","objectID":"/posts/website_video/:1:1","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"2. 嵌入B站视频 在此 html 中，我设定的 src 的传入参数是 bvid 和 page ，其中 page 是视频的指定视频选集 ( 对于多集视频可以自定义传参，默认为 1 ) 。 在 markdown 中需要嵌入视频的位置使用以下形式即可： {{\u003c bilibili BV1sz4y197L8 \u003e}} 对于有多集的视频，我想指定第 10 集，则是： {{\u003c bilibili BV1sz4y197L8 10 \u003e}} ","date":"2021-08-05","objectID":"/posts/website_video/:2:0","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"3. 嵌入 YouTube 视频 Hugo 貌似支持直接使用 YouTube 的视频嵌入，因为在我的博客的项目工程中我没有找到相关的 html 模板。YouTube 的网站链接做的相对友好：https://www.youtube.com/watch?v=XXXXXXXXXXX ，只需要把 v= 后面的内容复制到 ShortCodes 中即可，嵌入方式如下： {{\u003c youtube WNeLUngb-Xg \u003e}} 如果你想要自动播放，可以将其参数设置为 true 实现。由于我们不能将命名和未命名的参数混在一起使用，因此需要将尚未命名的视频 ID 分配给参数 id ： {{\u003c youtube id=\"w7Ft2ymGmfc\" autoplay=\"true\" \u003e}} ‍如果你的网站中无法直接嵌入 YouTube 的视频，那么如法炮制，在 /layouts/shortcodes/ 目录下创建一个 youbube.html 并粘贴下面的代码： \u003cdiv class=\"embed video-player\"\u003e \u003ciframe class=\"youtube-player\" type=\"text/html\" width=\"640\" height=\"385\" src=\"https://www.youtube.com/embed/{{ index .Params 0 }}?autoplay=1\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen frameborder=\"0\"\u003e \u003c/iframe\u003e \u003c/div\u003e \u003c!-- autoplay 也可以设置为 0 禁止自动播放，但是在 Safari 中无论如何设置都无法自动播放 --\u003e 然后再按照以上的 ShortCodes 进行嵌入即可。 或者你也可以通过直接在 markdown 中输入以下内容实现视频插入 ( 如果你不是经常需要嵌入视频的话 ) ： \u003cdiv class=\"embed video-player\" style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e \u003ciframe class=\"youtube-player\" type=\"text/html\" width=\"640\" height=\"385\" src=\"https://www.youtube.com/embed/WNeLUngb-Xg?autoplay=1\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen frameborder=\"0\"\u003e \u003c/iframe\u003e \u003c/div\u003e ","date":"2021-08-05","objectID":"/posts/website_video/:3:0","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"原文与参考链接 原文链接： 原文链接 参考链接： Create Your Own Shortcodes Shortcodes Of YouTube ","date":"2021-08-05","objectID":"/posts/website_video/:4:0","tags":["bilibili","video"],"title":"hugo在网页中添加视频","uri":"/posts/website_video/"},{"categories":["buildwebsite"],"content":"将域名与ip捆绑","date":"2021-07-22","objectID":"/posts/website_vpsdns/","tags":["DNS","Vps"],"title":"配置域名DNS","uri":"/posts/website_vpsdns/"},{"categories":["buildwebsite"],"content":"参考文章原文：这里 ","date":"2021-07-22","objectID":"/posts/website_vpsdns/:0:1","tags":["DNS","Vps"],"title":"配置域名DNS","uri":"/posts/website_vpsdns/"},{"categories":["buildwebsite"],"content":"配置域名DNS 在HostWinds找到域名Nameserver,如 mdns1.hostwindsdns.com。 mdns2.hostwindsdns.com。 到namesilo自己的域名设置的位置勾选要设置的域名然后changeserver，把这两个hostwinds的nameserver写入。 设置好之后到hostwinds的Domain添加一个domain，输入域名，状态显示为pending，要等待一段时间才会生效，一般很快，最长不超过48小时。 点击右测的Actions子菜单如果为Records表示已经生效，否则为Check。 生效之后点Records输入两个记录 1是@+ip 2是www+ip 完成后域名与ip就已经建立关系。 配置防火墙 # 安装防火墙，如果系统中已存在，那就会执行更新 yum -y install firewalld # 开机启动防火墙 systemctl enable firewalld # 立即启动防火墙 systemctl restart dbus systemctl restart firewalld # 查看防火墙的状态 systemctl status firewalld # 打开2200（自定义端口，修改SSH默认端口用，见下文）、80（HTTP）、443（HTTPS）端口 firewall-cmd --zone=public --add-port=2200/tcp --permanent firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=443/tcp --permanent # 更新防火墙规则 firewall-cmd --complete-reload # 查看所有打开的端口和服务 firewall-cmd --zone=public --list-ports firewall-cmd --list-services 防火墙安装并配置完毕 现在在浏览器中输入域名可以访问wp的设置主页 ","date":"2021-07-22","objectID":"/posts/website_vpsdns/:0:2","tags":["DNS","Vps"],"title":"配置域名DNS","uri":"/posts/website_vpsdns/"},{"categories":["other"],"content":"NBA直播地址收藏","date":"2021-07-22","objectID":"/posts/other_nbaurl/","tags":null,"title":"NBA直播地址收藏","uri":"/posts/other_nbaurl/"},{"categories":["other"],"content":"NBA/五大联赛免费看球链接： JRS直播吧：jrszhibo2018.com 低调看直播：didiaokan2018.com 球趣直播网：qiuquzhibo.com 极速体育吧：jisutiyuba.com JRS直播网：jrszhibo666.com 飞速直播网：feisuzhibo.com 黑白直播网：heibaizhibo.com 天天直播网：tiantianzhibo.com 爱看球直播：aikanqiu.com 24直播吧：24zhiboba.com 360直播网：360zhibo.com 433足球网：433zuqiu.com ","date":"2021-07-22","objectID":"/posts/other_nbaurl/:1:0","tags":null,"title":"NBA直播地址收藏","uri":"/posts/other_nbaurl/"},{"categories":["buildwebsite"],"content":"使用certbot添加ssl证书","date":"2021-07-22","objectID":"/posts/website_certbot_ssl/","tags":["certbot","ssl"],"title":"cerbot添加ssl证书","uri":"/posts/website_certbot_ssl/"},{"categories":["buildwebsite"],"content":"使用certbot添加ssl证书 参考文献： Centos7安装certbot获得并更新证书（使用Snap） Nginx on CentOS/RHEL 8 在 CentOS 上安装 snap 开始之前需要先卸载Certbot和其他Certbot OS包可参考这篇《卸载 certbot-auto》 ","date":"2021-07-22","objectID":"/posts/website_certbot_ssl/:0:0","tags":["certbot","ssl"],"title":"cerbot添加ssl证书","uri":"/posts/website_certbot_ssl/"},{"categories":["buildwebsite"],"content":"安装Snapd Snap在CentOS 7.6版本以上均可用，如果不知道你的版本，使用如下命令查看 cat /etc/centos-release 添加CentOS repository 什么是EPEL 及 Centos上安装EPEL CentOS 8 1. sudo dnf install epel-release 2. sudo dnf upgrade CentOS 7 sudo yum install epel-release 添加EPEL repository后，进行Snapd的安装 sudo yum install snapd 安装后，需要启用管理snap通信套接字的systemd unit sudo systemctl enable --now snapd.socket **为了启用_classic_ snap的支持，需要创建如下软连接** sudo ln -s /var/lib/snapd/snap /snap 这里可能会出现问题，重启即可，启动之后再执行该命令 ","date":"2021-07-22","objectID":"/posts/website_certbot_ssl/:0:1","tags":["certbot","ssl"],"title":"cerbot添加ssl证书","uri":"/posts/website_certbot_ssl/"},{"categories":["buildwebsite"],"content":"安装Certbot 升级snap 执行如下命令以保证Snap为最新的版本 sudo snap install core sudo snap refresh core 安装Certbot sudo snap install --classic certbot 配置Certbot命令行 执行如下命令以确保Certbot命令行可用 sudo ln -s /snap/bin/certbot /usr/bin/certbot 运行Certbot（二选一） 运行此命令获取证书，并让Certbot自动编辑Nginx配置以提供服务，只需一步即可打开HTTPS访问 sudo certbot --nginx 注： Certbot默认nginx配置文件在 /etc/nginx/nginx.conf 或 /usr/local/etc/nginx/nginx.conf,若你的nginx配置文件不在此处需在命令后加上 –nginx-server-root /usr/local/nginx/conf 仅获得证书。如果你希望手动配置nginx，输入如下命令 sudo certbot certonly --nginx ","date":"2021-07-22","objectID":"/posts/website_certbot_ssl/:0:2","tags":["certbot","ssl"],"title":"cerbot添加ssl证书","uri":"/posts/website_certbot_ssl/"},{"categories":["buildwebsite"],"content":"自动续期 您系统上的 Certbot 软件包带有一个 cron 作业或 systemd 计时器，它们会在您的证书到期之前自动更新您的证书。除非您更改配置，否则您无需再次运行 Certbot。 您可以通过运行以下命令来测试证书的自动续订： sudo certbot renew --dry-run ","date":"2021-07-22","objectID":"/posts/website_certbot_ssl/:0:3","tags":["certbot","ssl"],"title":"cerbot添加ssl证书","uri":"/posts/website_certbot_ssl/"},{"categories":["tools"],"content":"google搜索技巧的一些记录","date":"2021-07-20","objectID":"/posts/tools_googlesearch/","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"Google搜索小技巧 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:0","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"使用引号精确匹配 在需要搜索的关键词上加上双引号，搜索引擎就会返回和关键词吻合的搜索结果，否则会被拆分成几个词组进行检索 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:1","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"排除关键词- 操作符 在搜索关键词后面使用 - 操作符对指定内容进行排除，如AAAA-B只搜索排除B以外的AAAA搜索结果 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:2","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"使用通配符检索 ：* 通配符检索也就是所谓的模糊检索 如搜歌曲止战之殇只记得一句歌词，示例：*她只唱只想这首止战之殇* 或者我们想检索iu开头的单词，示例：iu* ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:3","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"数字范围搜索.. 只想查询某个数字范围的内容，可以在数字之间使用 .. 进行限制，如输入AAAA 1999-2000 年 就可以查询 1999-2000年的相关数据 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:4","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"使用 AND OR 操作符 搜索包含两个关键词的搜索结果。示例：AAAA AND BBBB 搜索两个关键词有一个就成的搜索结果。示例：AAAA OR BBBB ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:5","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"针对文件类型搜索 如果你只想查找 PDF 文件、Word 文档、或 EXCEL 表格，就可以使用 filetype: 操作符，支持的格式还有 ps 、dwf 、kml/kmz、ppt、rtf、swf 等。示例：filetype:pdf learn python ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:6","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"站内搜索 在输入框输入 site:+ 网址 + 关键词，可以直接搜索出网站内与关键词相关的内容。示例：site:iubucuoo.com unity ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:7","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"related关键词 related关键字可以搜索内容相关或者类似的网站 如淘宝购物，想知道做电商的其他的网站有哪些，可以搜索关键字related:taobao.com ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:8","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"Google学术搜索 Google 学术搜索不仅最大可能地索引了全球的论文期刊，其搜索结果的排序，也是按照论文的相关度、发表期刊、作者、影响因子等权重进行排名的 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:9","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["tools"],"content":"Goolge艺术与文化 Google 艺术与文化旨在汇聚全球多元性的文化与历史，强调人文性与艺术体验 ","date":"2021-07-20","objectID":"/posts/tools_googlesearch/:0:10","tags":["google","search"],"title":"Google搜索小技巧","uri":"/posts/tools_googlesearch/"},{"categories":["unity"],"content":"unity优化相关的一些记录","date":"2021-07-02","objectID":"/posts/unity3d_optimize/","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":" 对cpu性能优化 主要从drawcall、物理组建、GC、脚本等几个方面 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:0:0","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"Drawcall unity分动态批次和静态批次。两种批次都是需要对象的材质是共享的，不同材质的对象无法进行批次。 注在脚本中调用材质时，使用Renderer.material会造成材质的拷贝，而使用Render.sharedMaterial来调用则不会拷贝 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:1:0","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"静态批次 静态在场景中不可移动(标记static)，静态批次会把多个对象合并成一个打对象，会导致内存损耗，有时候也需要避免太多的静态批次造成内存过高。优化就是要平衡各个硬件的压力不能只针对一方面极致 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:1:1","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"动态批次 动态批次unity自动运行，也有一些自己的规则需要注意 动态批次是逐点处理的，仅对于小于900个顶点的mesh有效，如果shader使用了顶点位置、法线和UV那么仅支持低于300个顶点的mesh。如果再次基础上使用UV1、UV0和切向量，则最多支持180个顶点的mesh 缩放对动态批次也有影响，三轴同比例缩放的对象不会进行动态批次。非均匀缩放复制了具有烘培比例的网络-所以从渲染角度来看，它们根本没有被缩放，而是两份mesh(既然已经复制了mesh就顺带进行批次)。而对相同比例缩放来说使用的是同一份mesh此情况复制mesh来进行批次渲染不值得。 一定要使用同一个材质，即便两个一模一样也不会进行批次 拥有lightmap的物件因为有额外的材质属性(比如偏移和缩放系数)所以不能进行批次 多通道的shader会妨碍批处理操作，接收实时阴影的物件无法进行批次处理 渲染的顺序可能打断批次 比如一个材质夹在两个相同材质中间，这个时候两个相同材质的被隔开无法核批 渲染的顺序是根据物件到摄像机的距离进行从远到近的渲染，相同材质的对象尽量在一层。修改shader中渲染队列值，当小于等于2500时，unity会认为其不透明，对于不同材质但Z值相同对象，unity不对其进行排序，这样就算有其他材质插入也不会打破批次。如果队列值高于2500则会按顺序被打乱 知道渲染顺序这个规则，我们可以根据对象到相机的深度或者距离进行排列规则 场景里可以用Z轴来进行空间划分 UI里用深度来进行划分 人物模型等场景中的对象相对复杂，空间划分难度较大，只能尽量避免 一个特效使用多个材质，过程中也会引起drawcall波动，也可以进行相应的空间划分。 使用过后的特效等对象，在不起效的时候，应该设置为未激活状态，否则会继续占用drawcall，消耗设备的计算力，所以当一个对象使用后应当执行销毁或者未激活状态 打包图集 每个材质、纹理的渲染一定是会产生drawcall的，这个drawcall只能通过打包图集来进行优化，将多个纹理进行打包图集来减少材质，多个对象共享一个材质(纹理shader)合并的时候也要注意对同时出现的放在一起，不然会加载很多无用资源，造成内存占用升高 制作图集一般遵循几个规划 ： 从功能角度进行划分，如公共部分、每个具体的界面、功能上密切相关的打包到一起 不能将所有的东西打包到一个图集里面，特别不可能同时出项的东西，一个你不需要显示的图片会一直占用你的内存。 控制图集大小，不能让图集太大，一个很大的图集的drawcall消耗或许顶上十几个小图集的消耗 经过精心划分的图集与渲染顺序，drawcall一定有质的优化 使用灯光会打断drawcall，尽量使用烘培来实现光照效果 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:1:2","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"优化GC 尝试再适当的时机，手动触发GC和扩展堆大小，以便GC可控 将局部函数中的局部引用变量写成公共的 使用对象池 减少字符串创建，针对常用的字符串用id替代 注意装箱，装箱会产生垃圾源于底层，当一个值类型变量被装箱时，unity在堆上创建一个临时的object来包装值类型变量。一个object是一个引用类型的变量，所以当这个临时对象被处理时会产生垃圾。 Linq和正则在后台有装箱操作而产生垃圾 构建代码最小化GC 代码的构建方式可能会影响GC，即使代码中没有堆分配，也可能会增加GC的负担。可能增加GC的负担之一是要求检查他不改检查的东西，Struct是值类型的变量，但是如果包含一个引用的类型变量的Struct，那么垃圾收集器必须检查整个结构体。 另外一个增加GC负担的操作是使用不必要的对象，当垃圾收集器搜索堆上的对象的引用时，它必须检查代码中的每一个当前对象的引用，更少的对象引用意味着更少的工作量 foreach每次迭代会产生垃圾内存 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:2:0","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"脚本 Getcomponent 有三种获取方式 Getcomponent（string）—-\u003e在编写自定义调试台的时候，解析用户输入的字符串来获取组建的时候才适用，对于产品级的应用程序没理由使用 Getcomponent() Getcomponent(typeof(T)) 这两个方法获取的效率相差不大，根据每个版本优化的关系，经测试在untiy5的后续版本中最好使用 Getcomponent() Update函数调用Getcomponent等接口最好缓存 移除空的回调定义 如monobehaviour的Start()、Update()，完整的回调列表可通过untiy文档查找。当场景就有成千上万个空定义也会造成可观的性能消耗(可利用正则查找空的并移除) 在update中处理，如果可以隔多帧处理一次，如将 update(){DoSth();}修改为update() { if(Time.framecount %5 == 0) DoSth();} 脚本主要是针对update中复杂跟耗费的逻辑进行优化 共享计算输出，避免重复堆一个结果进行多次的计算 从gameobject取出字符串属性 从gameobject检索字符串属性是另一种意外跨越本机-托管桥接的微妙方式(gameobject的tag和name受到这个影响)应该只在性能无关的地方调用。 对于tag的属性常用比较Gameobject提供了CompareTag()方法(避免本地-托管桥接，不会导致内存分配与对应的垃圾回收)，name属性没有对应的办法，应该尽量少使用 对transform的属性修改，会通过其父对象的transform为对象生成正确的transform(意味着在hierarchy窗口越深的位置计算的越多)，在复杂的时间中对同一transform组建属性修改它每次都会触发内部消息进行一系列计算，因此属性修改可以通过缓存值在针尾来更改它来减少计算 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:3:0","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["unity"],"content":"Unity官方给出的一些优化建议 PC平台的话保持场景中显示的顶点数少于200K~3M，移动设备的话少于10W，一切取决于你的目标GPU与CPU。 如果你用U3D自带的SHADER，在表现不差的情况下选择Mobile或Unlit目录下的。它们更高效。 尽可能共用材质。 将不需要移动的物体设为Static，让引擎可以进行其批处理。 尽可能不用灯光。动态灯光更加不要了。 尝试用压缩贴图格式，或用16位代替32位。 如果不需要别用雾效(fog) 尝试用OcclusionCulling,在房间过道多遮挡物体多的场景非常有用。若不当反而会增加负担。 用天空盒去“褪去”远处的物体。 shader中用贴图混合的方式去代替多重通道计算。 shader中注意float/half/fixed的使用。 shader中不要用复杂的计算pow,sin,cos,tan,log等。 shader中越少Fragment越好。 注意是否有多余的动画脚本，模型自动导入到U3D会有动画脚本，大量的话会严重影响消耗CPU计算。 注意碰撞体的碰撞层，不必要的碰撞检测请舍去。 ","date":"2021-07-02","objectID":"/posts/unity3d_optimize/:3:1","tags":["Markdown","unity"],"title":"Unity优化","uri":"/posts/unity3d_optimize/"},{"categories":["ciencenet"],"content":"v2ray的服务器与客户端的搭建详情","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["ciencenet"],"content":"v2ray官网 详细教程及原理内容可查看V2Ray白话文教程 ","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/:0:0","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["ciencenet"],"content":"其他教程 搭建详细图文 在 Heroku 搭建 V2Ray (免费) ","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/:1:0","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["ciencenet"],"content":"服务器安装v2ray 安装wget yum -y install wget 下载脚本 wget https://install.direct/go.sh 安装unzip 因为centos不支持apt-get，我们需要安装unzip yum install zip unzip 执行安装 bash go.sh 安装脚本 运行以下脚本： curl -Ls https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh | sudo bash 里面可能会有报错信息，先不用管 获取用户ID 可以通过UUID Generator这个网站获取，也可以通过Linux命令生成： cat /proc/sys/kernel/random/uuid 配置 配置文件位于/etc/v2ray/config.json，可使用vim指令打开文本，也可以使用SSH图形话SFTP客户端如FileZilla，进入路径下载文件编辑， 启动V2Ray 启动： systemctl start v2ray 停止 systemctl stop v2ray 重启 systemctl restart v2ray 打开防火墙 centos系统防火墙需要开启 查看已开放端口 firewall-cmd --zone=public --list-ports 添加开放端口 firewall-cmd --zone=public --add-port=12345/tcp --permanent 重载防火墙配置，不然查看开放端口都查不到，也不能用，重载配置后即可 firewall-cmd --reload 如果哪一天发现怎么无法使用了，有可能是IP被屏蔽，也有肯能是端口被封，这个时候就需要换个端口，别忘记防火墙开启新端口，那旧端口就可以删除了。删除端口： firewall-cmd --zone=public --remove-port=123456/tcp --permanent ","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/:2:0","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["ciencenet"],"content":"v2ray多用户配置 修改时注意json格式 用指令：cat /etc/v2ray/config.json 打开配置文件config.json可以看到当前的配置。 运行指令cat /proc/sys/kernel/random/uuid或者UUID Generator获取uuid 用指令编辑config.json文件，指令： vim /etc/v2ray/config.json,输入i进入编辑模式，复制粘贴inbounds 中的一段内容，修改对应参数即可，参数不懂可用搜索引擎查找，接着Esc退出编辑模式，使用指令：:wq保存并退出文件。 可再用1步骤查看是否修改成功，然后重启v2ray服务： systemctl restart v2ray 别忘记开启防火墙端口 firewall-cmd --``zone=public --add-port=12346/tcp --permanent 重载防火墙配置 firewall-cmd --reload 如果不想改端口，可以复制clients[]中的一段内容并修改参数即可 ","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/:3:0","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["ciencenet"],"content":"客户端配置 [下载v2ray-core](https://github.com/v2ray/v2ray-core/releases) [下载v2ray-exe](https://github.com/2dust/v2rayN/releases) 两个下载完成解压，将exe文件夹下的V2RayN.exe和一个汉化文件夹复制到core下载解压后的目录。 运行V2RayN.exe并且将配置文件相应的对号入座即可完成配置 开启代理，右击运行的客户端图标，选中HTTP代理-\u003e开启PAC 即可 手机端软件下载地址：神一样的工具们 ","date":"2021-07-02","objectID":"/posts/ciencenet_v2ray/:4:0","tags":["v2ray","vps"],"title":"V2ray安装与使用","uri":"/posts/ciencenet_v2ray/"},{"categories":["buildwebsite"],"content":"从无到有，搭建网页记录","date":"2021-05-29","objectID":"/posts/website_vpsspace/","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"搭建个人页记录 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:0:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"常用命令操作 rm -rf 目录名字 删除文件夹以及文件夹中的所有文件命令 -r : 向下递归删除 -f : 直接强行删除，且没有任何提示 rm -f 文件名 删除文件命令行强行删除文件且无提示 pwd 查看当前路径 ls -l 查看当前路径下面的文件 i 进入编辑状态 :wq 保存退出 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:1:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"VPS与域名 根据自己的需求购买VPS 域名并解析IP ,我自己用的VPS是 HostWinds 域名是 namesilo ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:2:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"VPS上配置nginx 注 : Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。利用Nginx可以快速在vps上搭建web服务器 远程登陆到vps服务器 先创建三个目录 mkdir / blog#目录1，用作git上传的仓库目录，之后会用到 mkdir / tmp/blog#目录2，用作git clone的目录，之后会用到 mkdir / usr/share/nginx/html #目录3，用作nginx的webserver根目录，如果默认已经创建则忽略 安装nginx yum update yum install nginx 此时在本地浏览器访问域名就可以看到nginx的欢迎页面 配置Nginx.conf文件位置通过命令 nginx -t查看 vim编辑.conf文件 vim /usr/local/nginx/conf/nginx.conf 在http{}节点中增加（或修改） server { #服务器 listen 80; server_name www.test.com; # 你的域名 root /usr/share/nginx/html; # webserver根目录（目录3） } server { #跳转，直接输入test.com 或者ip地址，可跳转到www.test.com listen 80; server_name test.com; return 301 http://www.test.com; } 注: include /etc/nginx/sites-enabled/*; 要注释掉 否则网站的默认目录会是/var/www/html，而不是/usr/share/nginx/html了 配置完成 后面只需要将我们博客的内容放到配置文件中指定的webserver目录(/usr/share/nginx/html)，即可通过域名访问我们的博客 service nginx restart //重启服务 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:3:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"VPS上建git库 使用git来实现将本地的博客内容推到vps服务器上 在vps上建一个远程仓库，并且为这个仓库建一个hook，这样每次从本地push时，博客能同步更新 在vps上，进入之前创建的第一个目录 cd /blog git init --bare ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:4:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"建一个git hook 进入远程仓库的hooks目录进行操作： cd /blog/hooks vim post-receive 将以下内容写入post-recevie文件 注: 这段代码，会将本地每次push到vps上git仓库的内容，放到Nginx webserver目录（目录3） GIT_REPO=/blog #目录1 TMP_GIT_CLONE=/tmp/blog #目录2 NGINX_HTML=/usr/share/nginx/html#目录3 rm -rf ${TMP_GIT_CLONE} git clone $GIT_REPO $TMP_GIT_CLONE rm -rf ${NGINX_HTML}/* cp -rf ${TMP_GIT_CLONE}/* ${NGINX_HTML} 保存并退出，然后修改文件的权限 chmod 755 post-receive ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:5:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"编辑网页内容 这里我用到的是hugo 在本地下载好hugo可执行文件 Window: 下载好解压在某个路径 将这个路径添加到环境变量中(不然命令行无法执行到) Linux: yum install hugo 然后在hugo主页中进入教程，按着网页中的方式操作 生成静态文件public后进入下一步部署 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:6:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"内容部署到VPS 将前面生成的public目录初始化为git仓库，commit提交，再push到vps上就可以了 cd public git init git add --all git commit -m \"Initial blog repo\" #当前的工作目录下设置远程仓库的地址 git remote add origin ssh://your_user@VPS_IP:/blog #直接修改工作目录下远程仓库的地址(添加过可以不用再修改) git remote set-url origin ssh://your_user@VPS_IP:/blog # 若VPS的ssh默认端口不是22，需另设置ssh端口。 git push origin master 之后会提示输入密码，输入的时候不会显示直接输入就行。 push之后就可以通过域名访问到新编辑的网站了 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:7:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"上传更新的内容 之后每次编辑完内容，按着之前的方式生成静态网页public，进入public git add --all 添加所有修改 git commit -m \"xxxxxxxxx\" 提交修改 git push origin master ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:8:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"如何拉取内容到本地 cd public # 进入现有的本地目录 git clone ssh://your_user@VPS_IP:/blog# 第一次使用要把远程仓库的内容克隆到本地 #下拉 git fetch orgin master # 将远程仓库的 master 分支下载到本地当前 branch 中 git merge origin/master # 进行合并 # 上传 git add -all # 把所有变化加入缓存区 git commit -m \"xxxxxxxxx\" # 提交到本地仓库 git push origin master # 推送到远程仓库 origin 的 master 分支 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:9:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"},{"categories":["buildwebsite"],"content":"结束 待后续优化 添加钥避免每次输入密码 ","date":"2021-05-29","objectID":"/posts/website_vpsspace/:10:0","tags":["vps","hugo"],"title":"搭建网页记录","uri":"/posts/website_vpsspace/"}]